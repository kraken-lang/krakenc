// Kraken Self-Hosted Compiler — Entry Point
// CLI driver: reads source files, orchestrates the compilation pipeline
// (lex → translate → write C → invoke cc), and reports diagnostics.
//
// Usage:
//   krakenc <source.kr>                  Compile to executable
//   krakenc --emit-c <source.kr>         Emit C source only
//   krakenc --tokens <source.kr>         Dump token stream
//   krakenc --target <triple> <file>     Cross-compile for target
//   krakenc --targets                    List supported targets
//   krakenc --version                    Print version
//   krakenc --help                       Print usage

module main;

import token;
import lexer;
import ast;
import parser;
import codegen;
import error;
import platform;

// ---------------------------------------------------------------------------
// Version
// ---------------------------------------------------------------------------

fn COMPILER_VERSION() -> string { return "0.10.0-beta"; }
fn COMPILER_NAME() -> string    { return "krakenc"; }

// ---------------------------------------------------------------------------
// Compile mode
// ---------------------------------------------------------------------------

fn MODE_COMPILE() -> int  { return 0; }
fn MODE_EMIT_C() -> int   { return 1; }
fn MODE_TOKENS() -> int   { return 3; }
fn MODE_VERSION() -> int  { return 5; }
fn MODE_HELP() -> int     { return 6; }
fn MODE_TARGETS() -> int  { return 7; }

// ---------------------------------------------------------------------------
// Banner
// ---------------------------------------------------------------------------

fn print_banner() -> void {
    puts("  _  __          _              ");
    puts(" | |/ /_ __ __ _| | _____ _ __  ");
    puts(" | ' /| '__/ _` | |/ / _ \\ '_ \\ ");
    puts(" | . \\| | | (_| |   <  __/ | | |");
    puts(" |_|\\_\\_|  \\__,_|_|\\_\\___|_| |_|");
    puts("");
    puts(str_concat(" Kraken Language Compiler v", COMPILER_VERSION()));
    puts("");
}

fn print_version() -> void {
    puts(str_concat(str_concat(COMPILER_NAME(), " "), COMPILER_VERSION()));
}

fn print_help() -> void {
    print_banner();
    puts("Usage: krakenc [options] <source.kr>");
    puts("");
    puts("Options:");
    puts("  --emit-c              Emit C source only (no cc invocation)");
    puts("  --tokens              Dump token stream");
    puts("  --target <triple>     Cross-compile for target platform");
    puts("  --targets             List all supported target platforms");
    puts("  --version             Print compiler version");
    puts("  --help                Print this help message");
    puts("");
    puts("Target shortcuts: linux, macos, windows, freebsd, wasm");
    puts("");
}

// ---------------------------------------------------------------------------
// Derive output file paths from input path
// ---------------------------------------------------------------------------

fn derive_c_path(input: string) -> string {
    if (str_ends_with(input, ".kr")) {
        let base = str_slice(input, 0, strlen(input) - 3);
        return str_concat(base, ".c");
    }
    return str_concat(input, ".c");
}

fn derive_exe_path(input: string, target: Target) -> string {
    if (str_ends_with(input, ".kr")) {
        let base = str_slice(input, 0, strlen(input) - 3);
        return str_concat(base, exe_ext(target));
    }
    return str_concat(input, exe_ext(target));
}

// ---------------------------------------------------------------------------
// Dump token stream (--tokens mode)
// ---------------------------------------------------------------------------

// Interleaved int_data layout: [kind0, line0, col0, kind1, line1, col1, ...]
fn dump_tokens(int_data: VecInt, lexemes: VecString, count: int) -> void {
    let i = 0;
    while (i < count) {
        let k = vec_int_get(int_data, i * 3);
        let lex = vec_string_get(lexemes, i);
        let ln = vec_int_get(int_data, i * 3 + 1);
        let co = vec_int_get(int_data, i * 3 + 2);
        puts(str_concat(
            str_concat(fmt_int(ln), str_concat(":", str_concat(fmt_int(co), "  "))),
            str_concat(str_concat(token_kind_name(k), "  "), lex)
        ));
        i = i + 1;
    }
}

// ---------------------------------------------------------------------------
// Main — end-to-end compilation pipeline
// ---------------------------------------------------------------------------

fn main() -> int {
    // Detect host platform
    let target: Target = detect_host_target();
    let mode = MODE_COMPILE();
    let source_file = "";

    // Check for source file path via environment variables
    let has_input = false;
    let env_source = getenv("KRAKENC_INPUT");
    let env_mode = getenv("KRAKENC_MODE");
    let env_target = getenv("KRAKENC_TARGET");

    if (env_source != "") {
        source_file = env_source;
        has_input = true;
    }
    if (env_mode == "emit-c") { mode = MODE_EMIT_C(); }
    if (env_mode == "tokens") { mode = MODE_TOKENS(); }
    if (env_mode == "version") { mode = MODE_VERSION(); }
    if (env_mode == "help") { mode = MODE_HELP(); }
    if (env_mode == "targets") { mode = MODE_TARGETS(); }
    if (env_target != "") { target = parse_target(env_target); }

    // Handle non-compilation modes
    if (mode == MODE_VERSION()) {
        print_version();
        return 0;
    }
    if (mode == MODE_HELP()) {
        print_help();
        return 0;
    }
    if (mode == MODE_TARGETS()) {
        print_supported_targets();
        return 0;
    }

    print_banner();

    // Display target info
    puts(str_concat("  Host:     ", format_target(detect_host_target())));
    puts(str_concat("  Target:   ", format_target(target)));
    puts(str_concat("  CC:       ", default_cc(target)));
    let lflags = linker_flags(target);
    if (lflags != "") {
        puts(str_concat("  Linker:   ", lflags));
    }
    puts("");

    // Read source
    let source = "";
    if (has_input) {
        puts(str_concat("  Input:    ", source_file));
        source = file_read_string(source_file);
        if (source == "") {
            puts(str_concat("error: could not read file: ", source_file));
            return 1;
        }
    } else {
        // Built-in test program for development
        source_file = "test.kr";
        source = "fn main() -> int { return 0; }";
        puts("  Input:    <built-in test>");
    }

    // Phase 1: Lexing — tokenize into interleaved int_data + lexemes
    let int_data: VecInt = vec_int_new();
    let tok_lexemes: VecString = vec_string_new();

    let token_count = tokenize(source, int_data, tok_lexemes);
    puts(str_concat("  Tokens:   ", fmt_int(token_count)));

    if (mode == MODE_TOKENS()) {
        dump_tokens(int_data, tok_lexemes, token_count);
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 0;
    }

    // Phase 2: Translate — single-pass parse + C codegen
    let out: VecString = vec_string_new();
    let result: TranslateResult = translate(int_data, tok_lexemes, token_count, source_file, target, out);

    if (!result.success) {
        puts(str_concat("  Errors:   ", fmt_int(result.errors)));
        puts("Compilation failed.");
        vec_string_free(out);
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 1;
    }

    // Join output fragments into C source string
    let c_source: string = join_output(out);
    vec_string_free(out);

    // Determine output paths
    let c_path = derive_c_path(source_file);
    let exe_path = derive_exe_path(source_file, target);

    // Write C source to file
    let c_file: bytes = fopen(c_path, "w");
    fputs(c_source, c_file);
    fclose(c_file);
    puts(str_concat("  C output: ", c_path));

    if (mode == MODE_EMIT_C()) {
        puts("C source emitted successfully.");
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 0;
    }

    // Phase 3: Invoke C compiler
    let cc = default_cc(target);
    let cc_cmd = str_concat(cc, str_concat(" -o ", str_concat(exe_path, str_concat(" ", c_path))));
    let cc_lflags = linker_flags(target);
    if (cc_lflags != "") {
        cc_cmd = str_concat(cc_cmd, str_concat(" ", cc_lflags));
    }
    puts(str_concat("  CC cmd:   ", cc_cmd));

    let cc_result = system(cc_cmd);
    if (cc_result != 0) {
        puts("error: C compilation failed.");
        return 1;
    }

    puts(str_concat("  Output:   ", exe_path));
    puts("Build complete.");

    // Cleanup
    vec_int_free(int_data);
    vec_string_free(tok_lexemes);
    return 0;
}
