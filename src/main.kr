// Kraken Self-Hosted Compiler — Entry Point
// CLI driver: reads source files, orchestrates the compilation pipeline
// (lex → translate → write C → invoke cc), and reports diagnostics.
//
// Usage:
//   krakenc <source.kr>                  Compile to executable
//   krakenc --emit-c <source.kr>         Emit C source only
//   krakenc --tokens <source.kr>         Dump token stream
//   krakenc --target <triple> <file>     Cross-compile for target
//   krakenc --targets                    List supported targets
//   krakenc --version                    Print version
//   krakenc --help                       Print usage

module main;

import token;
import lexer;
import ast;
import parser;
import codegen;
import error;
import platform;

// ---------------------------------------------------------------------------
// Version
// ---------------------------------------------------------------------------

fn COMPILER_VERSION() -> string { return "0.9.3"; }
fn COMPILER_NAME() -> string    { return "krakenc"; }

// ---------------------------------------------------------------------------
// Compile mode
// ---------------------------------------------------------------------------

fn MODE_COMPILE() -> int  { return 0; }
fn MODE_EMIT_C() -> int   { return 1; }
fn MODE_TOKENS() -> int   { return 3; }
fn MODE_VERSION() -> int  { return 5; }
fn MODE_HELP() -> int     { return 6; }
fn MODE_TARGETS() -> int  { return 7; }

// ---------------------------------------------------------------------------
// Banner
// ---------------------------------------------------------------------------

fn print_banner() -> void {
    puts("  _  __          _              ");
    puts(" | |/ /_ __ __ _| | _____ _ __  ");
    puts(" | ' /| '__/ _` | |/ / _ \\ '_ \\ ");
    puts(" | . \\| | | (_| |   <  __/ | | |");
    puts(" |_|\\_\\_|  \\__,_|_|\\_\\___|_| |_|");
    puts("");
    puts(str_concat(" Kraken Language Compiler v", COMPILER_VERSION()));
    puts("");
}

fn print_version() -> void {
    puts(str_concat(str_concat(COMPILER_NAME(), " "), COMPILER_VERSION()));
}

fn print_help() -> void {
    print_banner();
    puts("Usage: krakenc [options] <source.kr>");
    puts("");
    puts("Options:");
    puts("  --emit-c              Emit C source only (no cc invocation)");
    puts("  --tokens              Dump token stream");
    puts("  --target <triple>     Cross-compile for target platform");
    puts("  --targets             List all supported target platforms");
    puts("  --version             Print compiler version");
    puts("  --help                Print this help message");
    puts("");
    puts("Target shortcuts: linux, macos, windows, freebsd, wasm");
    puts("");
}

// ---------------------------------------------------------------------------
// Import resolution — multi-file source concatenation
// ---------------------------------------------------------------------------

// Extract directory from a file path (everything up to and including the last '/')
fn dir_of(path: string) -> string {
    let len = strlen(path);
    let i = len - 1;
    while (i >= 0) {
        if (str_char_at(path, i) == 47) {
            return str_slice(path, 0, i + 1);
        }
        i = i - 1;
    }
    return "";
}

// Resolve imports: scan source for 'import <name>;' lines, read each file,
// and return the concatenated source (imports first, then original source).
fn resolve_imports(source: string, source_dir: string) -> string {
    let result = "";
    let len = strlen(source);
    let i = 0;
    while (i < len) {
        // Look for 'import ' at current position (after newline or start)
        if (i == 0 || str_char_at(source, i - 1) == 10) {
            // Skip whitespace
            let j = i;
            while (j < len && (str_char_at(source, j) == 32 || str_char_at(source, j) == 9)) {
                j = j + 1;
            }
            // Check for "import "
            if (j + 7 <= len && str_slice(source, j, j + 7) == "import ") {
                let k = j + 7;
                // Read module name
                while (k < len && str_char_at(source, k) != 59 && str_char_at(source, k) != 10) {
                    k = k + 1;
                }
                let mod_name = str_slice(source, j + 7, k);
                let mod_path = str_concat(source_dir, str_concat(mod_name, ".kr"));
                let mod_source = file_read_string(mod_path);
                if (mod_source != "") {
                    result = str_concat(result, str_concat(mod_source, "\n"));
                }
            }
        }
        i = i + 1;
    }
    // Append the original source after all imports
    result = str_concat(result, source);
    return result;
}

// ---------------------------------------------------------------------------
// Derive output file paths from input path
// ---------------------------------------------------------------------------

fn derive_c_path(input: string) -> string {
    if (str_ends_with(input, ".kr")) {
        let base = str_slice(input, 0, strlen(input) - 3);
        return str_concat(base, ".c");
    }
    return str_concat(input, ".c");
}

fn derive_exe_path(input: string, target: Target) -> string {
    if (str_ends_with(input, ".kr")) {
        let base = str_slice(input, 0, strlen(input) - 3);
        return str_concat(base, exe_ext(target));
    }
    return str_concat(input, exe_ext(target));
}

// ---------------------------------------------------------------------------
// Dump token stream (--tokens mode)
// ---------------------------------------------------------------------------

// Interleaved int_data layout: [kind0, line0, col0, kind1, line1, col1, ...]
fn dump_tokens(int_data: VecInt, lexemes: VecString, count: int) -> void {
    let i = 0;
    while (i < count) {
        let k = vec_int_get(int_data, i * 3);
        let lex = vec_string_get(lexemes, i);
        let ln = vec_int_get(int_data, i * 3 + 1);
        let co = vec_int_get(int_data, i * 3 + 2);
        puts(str_concat(
            str_concat(fmt_int(ln), str_concat(":", str_concat(fmt_int(co), "  "))),
            str_concat(str_concat(token_kind_name(k), "  "), lex)
        ));
        i = i + 1;
    }
}

// ---------------------------------------------------------------------------
// Main — end-to-end compilation pipeline
// ---------------------------------------------------------------------------

fn main() -> int {
    // Detect host platform
    let target: Target = detect_host_target();
    let mode = MODE_COMPILE();
    let source_file = "";

    // Check for source file path via environment variables
    let has_input = false;
    let env_source = getenv("KRAKENC_INPUT");
    let env_mode = getenv("KRAKENC_MODE");
    let env_target = getenv("KRAKENC_TARGET");

    if (env_source != "") {
        source_file = env_source;
        has_input = true;
    }
    if (env_mode == "emit-c") { mode = MODE_EMIT_C(); }
    if (env_mode == "tokens") { mode = MODE_TOKENS(); }
    if (env_mode == "version") { mode = MODE_VERSION(); }
    if (env_mode == "help") { mode = MODE_HELP(); }
    if (env_mode == "targets") { mode = MODE_TARGETS(); }
    if (env_target != "") { target = parse_target(env_target); }

    // Handle non-compilation modes
    if (mode == MODE_VERSION()) {
        print_version();
        return 0;
    }
    if (mode == MODE_HELP()) {
        print_help();
        return 0;
    }
    if (mode == MODE_TARGETS()) {
        print_supported_targets();
        return 0;
    }

    print_banner();

    // Display target info
    puts(str_concat("  Host:     ", format_target(detect_host_target())));
    puts(str_concat("  Target:   ", format_target(target)));
    puts(str_concat("  CC:       ", default_cc(target)));
    let lflags = linker_flags(target);
    if (lflags != "") {
        puts(str_concat("  Linker:   ", lflags));
    }
    puts("");

    // Read source
    let source = "";
    if (has_input) {
        puts(str_concat("  Input:    ", source_file));
        source = file_read_string(source_file);
        if (source == "") {
            puts(str_concat("error: could not read file: ", source_file));
            return 1;
        }
        // Resolve imports: read imported files and prepend their contents
        let src_dir = dir_of(source_file);
        source = resolve_imports(source, src_dir);
    } else {
        // Built-in test program for development
        source_file = "test.kr";
        source = "fn main() -> int { return 0; }";
        puts("  Input:    <built-in test>");
    }

    // Phase 1: Lexing — tokenize into interleaved int_data + lexemes
    let int_data: VecInt = vec_int_new();
    let tok_lexemes: VecString = vec_string_new();

    let token_count = tokenize(source, int_data, tok_lexemes);
    puts(str_concat("  Tokens:   ", fmt_int(token_count)));

    if (mode == MODE_TOKENS()) {
        dump_tokens(int_data, tok_lexemes, token_count);
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 0;
    }

    // Phase 2: Translate — single-pass parse + C codegen
    let out: VecString = vec_string_new();
    let result: TranslateResult = translate(int_data, tok_lexemes, token_count, source_file, target, out);

    if (!result.success) {
        puts(str_concat("  Errors:   ", fmt_int(result.errors)));
        puts("Compilation failed.");
        vec_string_free(out);
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 1;
    }

    // Join output fragments into C source string
    let c_source: string = join_output(out);
    vec_string_free(out);

    // Determine output paths
    let c_path = derive_c_path(source_file);
    let exe_path = derive_exe_path(source_file, target);

    // Write C source to file
    let c_file: bytes = fopen(c_path, "w");
    fputs(c_source, c_file);
    fclose(c_file);
    puts(str_concat("  C output: ", c_path));

    if (mode == MODE_EMIT_C()) {
        puts("C source emitted successfully.");
        vec_int_free(int_data);
        vec_string_free(tok_lexemes);
        return 0;
    }

    // Phase 3: Invoke C compiler
    let cc = default_cc(target);
    let cc_cmd = str_concat(cc, str_concat(" -o ", str_concat(exe_path, str_concat(" ", c_path))));
    let cc_lflags = linker_flags(target);
    if (cc_lflags != "") {
        cc_cmd = str_concat(cc_cmd, str_concat(" ", cc_lflags));
    }
    puts(str_concat("  CC cmd:   ", cc_cmd));

    let cc_result = system(cc_cmd);
    if (cc_result != 0) {
        puts("error: C compilation failed.");
        return 1;
    }

    puts(str_concat("  Output:   ", exe_path));
    puts("Build complete.");

    // Cleanup
    vec_int_free(int_data);
    vec_string_free(tok_lexemes);
    return 0;
}
