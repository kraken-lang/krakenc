// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <ctype.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
int64_t kr_fclose(void* f) { return (int64_t)fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }
int64_t kr_vec_int_pop(void* vp) { KrVecInt* v = (KrVecInt*)vp; return v->data[--v->len]; }
void kr_vec_int_clear(void* vp) { ((KrVecInt*)vp)->len = 0; }
int64_t kr_vec_int_capacity(void* vp) { return ((KrVecInt*)vp)->cap; }
void kr_vec_int_reserve(void* vp, int64_t n) {
  KrVecInt* v = (KrVecInt*)vp; if(n>v->cap){v->cap=n;v->data=(int64_t*)realloc(v->data,n*sizeof(int64_t));}
}
void* kr_vec_int_with_capacity(int64_t n) {
  KrVecInt* v=(KrVecInt*)malloc(sizeof(KrVecInt));v->data=(int64_t*)malloc(n*sizeof(int64_t));v->len=0;v->cap=n;return v;
}
void kr_vec_int_insert(void* vp, int64_t i, int64_t val) {
  KrVecInt* v=(KrVecInt*)vp; kr_vec_int_push(vp,0); memmove(&v->data[i+1],&v->data[i],(v->len-i-1)*sizeof(int64_t)); v->data[i]=val;
}
int64_t kr_vec_int_remove(void* vp, int64_t i) {
  KrVecInt* v=(KrVecInt*)vp; int64_t val=v->data[i]; memmove(&v->data[i],&v->data[i+1],(v->len-i-1)*sizeof(int64_t)); v->len--; return val;
}
int64_t kr_vec_int_swap_remove(void* vp, int64_t i) { KrVecInt* v=(KrVecInt*)vp; int64_t val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
void kr_vec_int_shrink_to_fit(void* vp) { KrVecInt* v=(KrVecInt*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(int64_t*)realloc(v->data,v->cap*sizeof(int64_t));} }
kr_str kr_vec_string_pop(void* vp) { KrVecString* v = (KrVecString*)vp; return v->data[--v->len]; }
void kr_vec_string_clear(void* vp) { ((KrVecString*)vp)->len = 0; }
int64_t kr_vec_string_capacity(void* vp) { return ((KrVecString*)vp)->cap; }
void kr_vec_string_reserve(void* vp, int64_t n) {
  KrVecString* v = (KrVecString*)vp; if(n>v->cap){v->cap=n;v->data=(char**)realloc(v->data,n*sizeof(char*));}
}
void* kr_vec_string_with_capacity(int64_t n) {
  KrVecString* v=(KrVecString*)malloc(sizeof(KrVecString));v->data=(char**)malloc(n*sizeof(char*));v->len=0;v->cap=n;return v;
}
void kr_vec_string_shrink_to_fit(void* vp) { KrVecString* v=(KrVecString*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(char**)realloc(v->data,v->cap*sizeof(char*));} }
kr_str kr_vec_string_swap_remove(void* vp, int64_t i) { KrVecString* v=(KrVecString*)vp; kr_str val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
typedef struct { void** data; int64_t len; int64_t cap; } KrVecBytes;
void* kr_vec_bytes_new() { KrVecBytes* v=(KrVecBytes*)malloc(sizeof(KrVecBytes)); v->data=(void**)malloc(16*sizeof(void*)); v->len=0; v->cap=16; return v; }
void kr_vec_bytes_push(void* vp, void* val) { KrVecBytes* v=(KrVecBytes*)vp; if(v->len>=v->cap){v->cap*=2;v->data=(void**)realloc(v->data,v->cap*sizeof(void*));} v->data[v->len++]=val; }
void* kr_vec_bytes_get(void* vp, int64_t i) { return ((KrVecBytes*)vp)->data[i]; }
void kr_vec_bytes_set(void* vp, int64_t i, void* val) { ((KrVecBytes*)vp)->data[i]=val; }
int64_t kr_vec_bytes_len(void* vp) { return ((KrVecBytes*)vp)->len; }
void kr_vec_bytes_free(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; free(v->data); free(v); }
void* kr_vec_bytes_pop(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; return v->data[--v->len]; }
void kr_vec_bytes_clear(void* vp) { ((KrVecBytes*)vp)->len=0; }
int64_t kr_vec_bytes_capacity(void* vp) { return ((KrVecBytes*)vp)->cap; }
void kr_vec_bytes_reserve(void* vp, int64_t n) { KrVecBytes* v=(KrVecBytes*)vp; if(n>v->cap){v->cap=n;v->data=(void**)realloc(v->data,n*sizeof(void*));} }
void* kr_vec_bytes_with_capacity(int64_t n) { KrVecBytes* v=(KrVecBytes*)malloc(sizeof(KrVecBytes)); v->data=(void**)malloc(n*sizeof(void*)); v->len=0; v->cap=n; return v; }
void kr_vec_bytes_shrink_to_fit(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(void**)realloc(v->data,v->cap*sizeof(void*));} }
void* kr_vec_bytes_swap_remove(void* vp, int64_t i) { KrVecBytes* v=(KrVecBytes*)vp; void* val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
typedef struct { char** keys; int64_t* vals; int64_t cap; int64_t len; } KrMapSI;
static uint64_t _kr_hash_str(const char* s) { uint64_t h=5381; while(*s) h=h*33+(*s++); return h; }
void* kr_map_string_int_new() {
  KrMapSI* m=(KrMapSI*)malloc(sizeof(KrMapSI)); m->cap=64; m->len=0;
  m->keys=(char**)calloc(64,sizeof(char*)); m->vals=(int64_t*)calloc(64,sizeof(int64_t)); return m;
}
void kr_map_string_int_set(void* mp, kr_str key, int64_t val) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){m->vals[h]=val;return;} h=(h+1)%m->cap;}
  m->keys[h]=strdup(key); m->vals[h]=val; m->len++;
}
int64_t kr_map_string_int_get(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return m->vals[h]; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_int_has(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return 1; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_int_len(void* mp) { return ((KrMapSI*)mp)->len; }
void kr_map_string_int_delete(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->keys[h]);m->keys[h]=NULL;m->len--;return;} h=(h+1)%m->cap;}
}
void kr_map_string_int_clear(void* mp) { KrMapSI* m=(KrMapSI*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i])free(m->keys[i]);m->keys[i]=NULL;} m->len=0; }
void kr_map_string_int_free(void* mp) { KrMapSI* m=(KrMapSI*)mp; for(int64_t i=0;i<m->cap;i++)if(m->keys[i])free(m->keys[i]); free(m->keys);free(m->vals);free(m); }
void* kr_map_string_int_keys(void* mp) { KrMapSI* m=(KrMapSI*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->keys[i]); return v; }
void* kr_map_string_int_values(void* mp) { KrMapSI* m=(KrMapSI*)mp; void* v=kr_vec_int_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_int_push(v,m->vals[i]); return v; }
typedef struct { char** keys; char** vals; int64_t cap; int64_t len; } KrMapSS;
void* kr_map_string_string_new() {
  KrMapSS* m=(KrMapSS*)malloc(sizeof(KrMapSS)); m->cap=64; m->len=0;
  m->keys=(char**)calloc(64,sizeof(char*)); m->vals=(char**)calloc(64,sizeof(char*)); return m;
}
void kr_map_string_string_set(void* mp, kr_str key, kr_str val) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->vals[h]);m->vals[h]=strdup(val);return;} h=(h+1)%m->cap;}
  m->keys[h]=strdup(key); m->vals[h]=strdup(val); m->len++;
}
kr_str kr_map_string_string_get(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return m->vals[h]; h=(h+1)%m->cap;} return "";
}
int64_t kr_map_string_string_has(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return 1; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_string_len(void* mp) { return ((KrMapSS*)mp)->len; }
void kr_map_string_string_delete(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->keys[h]);free(m->vals[h]);m->keys[h]=NULL;m->vals[h]=NULL;m->len--;return;} h=(h+1)%m->cap;}
}
void kr_map_string_string_clear(void* mp) { KrMapSS* m=(KrMapSS*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i]){free(m->keys[i]);free(m->vals[i]);m->keys[i]=NULL;m->vals[i]=NULL;}} m->len=0; }
void kr_map_string_string_free(void* mp) { KrMapSS* m=(KrMapSS*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i]){free(m->keys[i]);free(m->vals[i]);}} free(m->keys);free(m->vals);free(m); }
void* kr_map_string_string_keys(void* mp) { KrMapSS* m=(KrMapSS*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->keys[i]); return v; }
void* kr_map_string_string_values(void* mp) { KrMapSS* m=(KrMapSS*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->vals[i]); return v; }
kr_str kr_fmt_float(double v, ...) { char* r=(char*)malloc(64); snprintf(r,64,"%g",v); return r; }
kr_str kr_fmt_bool(int64_t v) { return v ? "true" : "false"; }
kr_str kr_fmt_hex(int64_t v) { char* r=(char*)malloc(32); snprintf(r,32,"0x%llx",(unsigned long long)v); return r; }
#define kr_printf(...) printf(__VA_ARGS__)
void kr_putchar(int64_t c) { putchar((int)c); }
int64_t kr_getchar() { return (int64_t)getchar(); }
void* kr_malloc(int64_t sz) { return malloc((size_t)sz); }
void kr_free(void* p) { free(p); }
void* kr_realloc(void* p, int64_t sz) { return realloc(p,(size_t)sz); }
int64_t kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
int64_t kr_str_ne(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
int64_t kr_str_len(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_str_contains(kr_str s, kr_str sub) { return strstr(s,sub)!=NULL; }
int64_t kr_str_starts_with(kr_str s, kr_str pfx) { return strncmp(s,pfx,strlen(pfx))==0; }
int64_t kr_str_index_of(kr_str s, kr_str sub) { char* p=strstr(s,sub); return p?(int64_t)(p-s):-1; }
kr_str kr_str_replace(kr_str s, kr_str old, kr_str rep) {
  size_t ol=strlen(old),rl=strlen(rep),sl=strlen(s); char* r=(char*)malloc(sl*2+1); char* w=r;
  while(*s){char* p=strstr(s,old);if(!p){strcpy(w,s);break;}memcpy(w,s,p-s);w+=p-s;memcpy(w,rep,rl);w+=rl;s=p+ol;}*w=0;return r;
}
kr_str kr_str_to_lower(kr_str s) { size_t n=strlen(s); char* r=(char*)malloc(n+1); for(size_t i=0;i<=n;i++)r[i]=tolower((unsigned char)s[i]); return r; }
kr_str kr_str_to_upper(kr_str s) { size_t n=strlen(s); char* r=(char*)malloc(n+1); for(size_t i=0;i<=n;i++)r[i]=toupper((unsigned char)s[i]); return r; }
kr_str kr_str_trim(kr_str s) { while(*s==' '||*s=='\t'||*s=='\n'||*s=='\r')s++; size_t n=strlen(s); while(n>0&&(s[n-1]==' '||s[n-1]=='\t'||s[n-1]=='\n'||s[n-1]=='\r'))n--; char* r=(char*)malloc(n+1); memcpy(r,s,n); r[n]=0; return r; }
kr_str kr_strdup(kr_str s) { return strdup(s); }
kr_str kr_from_cstr(void* p) { return p ? (kr_str)p : ""; }
void* kr_cstr(kr_str s) { return (void*)s; }
int64_t kr_str_char_count(kr_str s) { return (int64_t)strlen(s); }
kr_str kr_str_from_char_code(int64_t c) { char* r=(char*)malloc(2); r[0]=(char)c; r[1]=0; return r; }
kr_str kr_str_join(void* vp, kr_str sep) {
  KrVecString* v=(KrVecString*)vp; if(!v->len) return ""; size_t total=0,sl=strlen(sep);
  for(int64_t i=0;i<v->len;i++) total+=strlen(v->data[i]); total+=(v->len-1)*sl;
  char* r=(char*)malloc(total+1); char* w=r;
  for(int64_t i=0;i<v->len;i++){if(i>0){memcpy(w,sep,sl);w+=sl;}size_t n=strlen(v->data[i]);memcpy(w,v->data[i],n);w+=n;} *w=0; return r;
}
void* kr_str_split(kr_str s, kr_str sep) {
  void* v=kr_vec_string_new(); size_t sl=strlen(sep);
  while(*s){char* p=strstr(s,sep);if(!p){kr_vec_string_push(v,strdup(s));break;}
  char* chunk=(char*)malloc(p-s+1);memcpy(chunk,s,p-s);chunk[p-s]=0;kr_vec_string_push(v,chunk);s=p+sl;} return v;
}
int64_t kr_rand() { return (int64_t)rand(); }
void kr_srand(int64_t seed) { srand((unsigned)seed); }
double kr_sqrt(double x) { return sqrt(x); }
double kr_pow(double x, double y) { return pow(x,y); }
double kr_floor(double x) { return floor(x); }
double kr_ceil(double x) { return ceil(x); }
double kr_round(double x) { return round(x); }
double kr_sin(double x) { return sin(x); }
double kr_cos(double x) { return cos(x); }
double kr_tan(double x) { return tan(x); }
double kr_log(double x) { return log(x); }
double kr_log10(double x) { return log10(x); }
double kr_exp(double x) { return exp(x); }
double kr_fabs(double x) { return fabs(x); }
double kr_fmod(double x, double y) { return fmod(x,y); }
double kr_atan2(double y, double x) { return atan2(y,x); }
double kr_asin(double x) { return asin(x); }
double kr_acos(double x) { return acos(x); }
double kr_atan(double x) { return atan(x); }
double kr_sinh(double x) { return sinh(x); }
double kr_cosh(double x) { return cosh(x); }
double kr_tanh(double x) { return tanh(x); }
static int _kr_test_count=0, _kr_test_pass=0, _kr_test_fail=0;
static inline void _kr_default_test_section(kr_str name) { printf("--- %s ---\n", name); }
static inline void _kr_default_test_pass(kr_str msg) { _kr_test_count++; _kr_test_pass++; printf("  PASS: %s\n", msg); }
static inline void _kr_default_test_fail(kr_str msg) { _kr_test_count++; _kr_test_fail++; printf("  FAIL: %s\n", msg); }
static inline void _kr_default_test_skip(kr_str msg) { printf("  SKIP: %s\n", msg); }
static inline void _kr_default_assert(int64_t cond) { if(!cond){printf("ASSERTION FAILED\n");exit(1);} }
static inline void _kr_default_assert_eq(int64_t a, int64_t b) {
  _kr_test_count++; if(a==b){_kr_test_pass++;}else{_kr_test_fail++;printf("  ASSERT_EQ FAILED: %lld != %lld\n",(long long)a,(long long)b);}
}
static inline void _kr_default_assert_ne(int64_t a, int64_t b) {
  _kr_test_count++; if(a!=b){_kr_test_pass++;}else{_kr_test_fail++;printf("  ASSERT_NE FAILED: %lld == %lld\n",(long long)a,(long long)b);}
}
#define kr_test_section _kr_default_test_section
#define kr_test_pass _kr_default_test_pass
#define kr_test_fail _kr_default_test_fail
#define kr_test_skip _kr_default_test_skip
#define kr_assert _kr_default_assert
#define kr_assert_eq _kr_default_assert_eq
#define kr_assert_ne _kr_default_assert_ne
void* kr_mutex_create() { return malloc(64); }
void kr_mutex_destroy(void* m) { free(m); }
void kr_mutex_lock(void* m) { (void)m; }
void kr_mutex_unlock(void* m) { (void)m; }
void* kr_thread_spawn(void* fn) { (void)fn; return NULL; }
void kr_thread_join(void* h) { (void)h; }
void kr_sleep_ms(int64_t ms) { usleep((unsigned)(ms*1000)); }
int64_t kr_time() { return (int64_t)time(NULL); }
int64_t kr_isalpha(int64_t c) { return isalpha((int)c); }
int64_t kr_isdigit(int64_t c) { return isdigit((int)c); }
int64_t kr_isalnum(int64_t c) { return isalnum((int)c); }
int64_t kr_isupper(int64_t c) { return isupper((int)c); }
int64_t kr_islower(int64_t c) { return islower((int)c); }
int64_t kr_isspace(int64_t c) { return isspace((int)c); }
int64_t kr_tolower(int64_t c) { return (int64_t)tolower((int)c); }
int64_t kr_toupper(int64_t c) { return (int64_t)toupper((int)c); }
int64_t kr_atoi(kr_str s) { return (int64_t)atoi(s); }
double kr_atof(kr_str s) { return atof(s); }
void kr_abort() { abort(); }
kr_str kr_fgets(kr_str buf, int64_t n, void* f) { return fgets(buf,(int)n,(FILE*)f); }
int64_t kr_fwrite(void* ptr, int64_t size, int64_t count, void* f) { return (int64_t)fwrite(ptr,(size_t)size,(size_t)count,(FILE*)f); }
int64_t kr_fread(void* ptr, int64_t size, int64_t count, void* f) { return (int64_t)fread(ptr,(size_t)size,(size_t)count,(FILE*)f); }
int64_t kr_feof(void* f) { return (int64_t)feof((FILE*)f); }
int64_t kr_ferror(void* f) { return (int64_t)ferror((FILE*)f); }
int64_t kr_fflush(void* f) { return (int64_t)fflush((FILE*)f); }
int64_t kr_fgetc(void* f) { return (int64_t)fgetc((FILE*)f); }
int64_t kr_fputc(int64_t c, void* f) { return (int64_t)fputc((int)c,(FILE*)f); }
int64_t kr_fseek(void* f, int64_t off, int64_t w) { return (int64_t)fseek((FILE*)f,(long)off,(int)w); }
int64_t kr_ftell(void* f) { return (int64_t)ftell((FILE*)f); }
void kr_rewind(void* f) { rewind((FILE*)f); }
int64_t kr_memcmp(void* a, void* b, int64_t n) { return (int64_t)memcmp(a,b,(size_t)n); }
void* kr_memcpy(void* dst, void* src, int64_t n) { return memcpy(dst,src,(size_t)n); }
void* kr_memmove(void* dst, void* src, int64_t n) { return memmove(dst,src,(size_t)n); }
void* kr_memset(void* p, int64_t c, int64_t n) { return memset(p,(int)c,(size_t)n); }
void kr_setenv(kr_str name, kr_str val, ...) { setenv(name,val,1); }
void kr_unsetenv(kr_str name) { unsetenv(name); }
kr_str kr_strstr(kr_str haystack, kr_str needle) { char* p=strstr(haystack,needle); return p?p:""; }
kr_str kr_strchr(kr_str s, int64_t c) { char* p=strchr(s,(int)c); return p?p:""; }
kr_str kr_strncpy(kr_str dst, kr_str src, int64_t n) { return strncpy(dst,src,(size_t)n); }
kr_str kr_strcat(kr_str dst, kr_str src) { return strcat(dst,src); }
kr_str kr_strcpy(kr_str dst, kr_str src) { return strcpy(dst,src); }
int64_t kr_strncmp(kr_str a, kr_str b, int64_t n) { return (int64_t)strncmp(a,b,(size_t)n); }
kr_str kr_strtok(kr_str s, kr_str d) { return strtok(s,d); }
int64_t kr_str_is_valid_utf8(kr_str s) { while(*s){unsigned char c=*s;if(c<0x80)s++;else if((c&0xE0)==0xC0){if((s[1]&0xC0)!=0x80)return 0;s+=2;}else if((c&0xF0)==0xE0){if((s[1]&0xC0)!=0x80||(s[2]&0xC0)!=0x80)return 0;s+=3;}else if((c&0xF8)==0xF0){if((s[1]&0xC0)!=0x80||(s[2]&0xC0)!=0x80||(s[3]&0xC0)!=0x80)return 0;s+=4;}else return 0;} return 1; }
int64_t kr_str_char_at_utf8(kr_str s, int64_t idx) { return (int64_t)(unsigned char)s[idx]; }
int64_t kr_block_on(void* future) { (void)future; return 0; }
#define kr_sprintf(...) sprintf(__VA_ARGS__)
#define kr_sscanf(...) sscanf(__VA_ARGS__)
#define kr_snprintf(...) snprintf(__VA_ARGS__)
int64_t kr_rand_int(int64_t lo, int64_t hi) { return lo + (rand() % (hi - lo + 1)); }
double kr_rand_float() { return (double)rand() / (double)RAND_MAX; }
void kr_rand_seed(int64_t seed) { srand((unsigned)seed); }
int64_t kr_math_abs(int64_t x) { return x<0?-x:x; }
int64_t kr_math_min(int64_t a, int64_t b) { return a<b?a:b; }
int64_t kr_math_max(int64_t a, int64_t b) { return a>b?a:b; }
double kr_math_sqrt(double x) { return sqrt(x); }
double kr_math_floor(double x) { return floor(x); }
double kr_math_ceil(double x) { return ceil(x); }
double kr_math_round(double x) { return round(x); }
double kr_math_sin(double x) { return sin(x); }
double kr_math_cos(double x) { return cos(x); }
double kr_math_tan(double x) { return tan(x); }
double kr_math_pow(double x, double y) { return pow(x,y); }
void kr_log_debug(kr_str msg) { fprintf(stderr,"[DEBUG] %s\n",msg); }
void kr_log_info(kr_str msg) { fprintf(stderr,"[INFO] %s\n",msg); }
void kr_log_warn(kr_str msg) { fprintf(stderr,"[WARN] %s\n",msg); }
void kr_log_error(kr_str msg) { fprintf(stderr,"[ERROR] %s\n",msg); }
void kr_log_set_level(int64_t lvl) { (void)lvl; }
int64_t kr_bench_start() { return (int64_t)clock(); }
int64_t kr_bench_end(int64_t start, ...) { return (int64_t)clock() - start; }
int64_t kr_remove(kr_str path) { return (int64_t)remove(path); }
int64_t kr_rename(kr_str old, kr_str new_path) { return (int64_t)rename(old,new_path); }
void* kr_rand_bytes(int64_t n) { void* buf=malloc((size_t)n); for(int64_t i=0;i<n;i++)((char*)buf)[i]=(char)rand(); return buf; }
int64_t kr_bytes_eq(void* a, void* b, int64_t n) { return memcmp(a,b,(size_t)n)==0; }
void kr_println(kr_str s) { printf("%s\n",s); }
void* kr_mutex_new() { return malloc(64); }
void kr_mutex_free(void* m) { free(m); }
void* kr_channel_new() { return NULL; }
void* kr_channel_create(int64_t cap) { (void)cap; return NULL; }
void kr_channel_send(void* ch, int64_t val) { (void)ch; (void)val; }
int64_t kr_channel_recv(void* ch) { (void)ch; return 0; }
int64_t kr_channel_try_send(void* ch, int64_t val) { (void)ch; (void)val; return 0; }
int64_t kr_channel_try_recv(void* ch) { (void)ch; return 0; }
void kr_channel_close(void* ch) { (void)ch; }
void* kr_condvar_create() { return malloc(64); }
void kr_condvar_destroy(void* cv) { free(cv); }
void kr_condvar_signal(void* cv) { (void)cv; }
void kr_condvar_broadcast(void* cv) { (void)cv; }
void* kr_pool_new(int64_t n) { (void)n; return malloc(8); }
void kr_pool_shutdown(void* p) { free(p); }
void* kr_executor_new() { return malloc(8); }
void kr_executor_run(void* e) { (void)e; }
void kr_executor_shutdown(void* e) { free(e); }
void* kr_cancel_token_new() { return calloc(1,sizeof(int64_t)); }
void kr_cancel_token_cancel(void* t) { *(int64_t*)t=1; }
int64_t kr_cancel_token_is_cancelled(void* t) { return *(int64_t*)t; }

/* Forward declarations */
typedef struct SourceLocation SourceLocation;
typedef struct Token Token;
typedef struct Lexer Lexer;
typedef struct AstNode AstNode;
typedef struct AstArena AstArena;
typedef struct TypeNode TypeNode;
typedef struct Parameter Parameter;
typedef struct Field Field;
typedef struct MatchArm MatchArm;
typedef struct Translator Translator;
typedef struct TranslateResult TranslateResult;
typedef struct Diagnostic Diagnostic;
typedef struct Target Target;
SourceLocation kr_new_location(int64_t line, int64_t column, int64_t offset);
Token kr_new_token(int64_t kind, kr_str lexeme, int64_t line, int64_t column);
int64_t kr_TK_INT_LIT();
int64_t kr_TK_FLOAT_LIT();
int64_t kr_TK_STRING_LIT();
int64_t kr_TK_BOOL_LIT();
int64_t kr_TK_IDENTIFIER();
int64_t kr_TK_KW_IF();
int64_t kr_TK_KW_ELSE();
int64_t kr_TK_KW_MATCH();
int64_t kr_TK_KW_FOR();
int64_t kr_TK_KW_WHILE();
int64_t kr_TK_KW_DO();
int64_t kr_TK_KW_BREAK();
int64_t kr_TK_KW_CONTINUE();
int64_t kr_TK_KW_RETURN();
int64_t kr_TK_KW_FN();
int64_t kr_TK_KW_LET();
int64_t kr_TK_KW_CONST();
int64_t kr_TK_KW_MODULE();
int64_t kr_TK_KW_IMPORT();
int64_t kr_TK_KW_STRUCT();
int64_t kr_TK_KW_ENUM();
int64_t kr_TK_KW_TRAIT();
int64_t kr_TK_KW_IMPL();
int64_t kr_TK_KW_TYPE();
int64_t kr_TK_KW_PUB();
int64_t kr_TK_KW_PRIV();
int64_t kr_TK_KW_STATIC();
int64_t kr_TK_KW_ASYNC();
int64_t kr_TK_KW_AWAIT();
int64_t kr_TK_KW_SPAWN();
int64_t kr_TK_KW_REF();
int64_t kr_TK_KW_MUT();
int64_t kr_TK_KW_MOVE();
int64_t kr_TK_KW_UNSAFE();
int64_t kr_TK_KW_TRUE();
int64_t kr_TK_KW_FALSE();
int64_t kr_TK_KW_NULL();
int64_t kr_TK_KW_SELF();
int64_t kr_TK_KW_SUPER();
int64_t kr_TK_KW_DEFER();
int64_t kr_TK_KW_WHERE();
int64_t kr_TK_KW_AS();
int64_t kr_TK_KW_IN();
int64_t kr_TK_KW_DYN();
int64_t kr_TK_KW_UNION();
int64_t kr_TK_KW_CLASS();
int64_t kr_TK_KW_INTERFACE();
int64_t kr_TK_KW_INT();
int64_t kr_TK_KW_FLOAT();
int64_t kr_TK_KW_BOOL();
int64_t kr_TK_KW_STRING();
int64_t kr_TK_KW_STR();
int64_t kr_TK_KW_BYTES();
int64_t kr_TK_KW_VOID();
int64_t kr_TK_OP_PLUS();
int64_t kr_TK_OP_MINUS();
int64_t kr_TK_OP_STAR();
int64_t kr_TK_OP_SLASH();
int64_t kr_TK_OP_PERCENT();
int64_t kr_TK_OP_EQ();
int64_t kr_TK_OP_NEQ();
int64_t kr_TK_OP_LT();
int64_t kr_TK_OP_LTE();
int64_t kr_TK_OP_GT();
int64_t kr_TK_OP_GTE();
int64_t kr_TK_OP_AND();
int64_t kr_TK_OP_OR();
int64_t kr_TK_OP_NOT();
int64_t kr_TK_OP_BIT_AND();
int64_t kr_TK_OP_BIT_OR();
int64_t kr_TK_OP_BIT_XOR();
int64_t kr_TK_OP_BIT_NOT();
int64_t kr_TK_OP_LSHIFT();
int64_t kr_TK_OP_RSHIFT();
int64_t kr_TK_OP_ASSIGN();
int64_t kr_TK_OP_PLUS_ASSIGN();
int64_t kr_TK_OP_MINUS_ASSIGN();
int64_t kr_TK_OP_STAR_ASSIGN();
int64_t kr_TK_OP_SLASH_ASSIGN();
int64_t kr_TK_OP_PERCENT_ASSIGN();
int64_t kr_TK_OP_DOT_DOT();
int64_t kr_TK_OP_DOT_DOT_EQ();
int64_t kr_TK_LPAREN();
int64_t kr_TK_RPAREN();
int64_t kr_TK_LBRACE();
int64_t kr_TK_RBRACE();
int64_t kr_TK_LBRACKET();
int64_t kr_TK_RBRACKET();
int64_t kr_TK_SEMICOLON();
int64_t kr_TK_COMMA();
int64_t kr_TK_DOT();
int64_t kr_TK_COLON();
int64_t kr_TK_COLON_COLON();
int64_t kr_TK_ARROW();
int64_t kr_TK_QUESTION();
int64_t kr_TK_PIPE();
int64_t kr_TK_HASH();
int64_t kr_TK_EOF();
int64_t kr_TK_NEWLINE();
int64_t kr_TK_COMMENT();
int64_t kr_lookup_keyword(kr_str s);
kr_str kr_token_kind_name(int64_t kind);
bool kr_is_keyword(int64_t kind);
bool kr_is_operator(int64_t kind);
bool kr_is_delimiter(int64_t kind);
bool kr_is_type_keyword(int64_t kind);
Lexer kr_new_lexer(kr_str source);
bool kr_is_alpha(int64_t c);
bool kr_is_digit(int64_t c);
bool kr_is_alnum(int64_t c);
bool kr_is_whitespace(int64_t c);
bool kr_at_end(Lexer lex);
int64_t kr_peek_char(Lexer lex);
int64_t kr_peek_next(Lexer lex);
Lexer kr_advance(Lexer lex);
Lexer kr_skip_whitespace(Lexer lex);
Token kr_read_identifier(Lexer lex);
Token kr_read_number(Lexer lex);
Token kr_read_string(Lexer lex);
Token kr_read_operator(Lexer lex);
int64_t kr_token_advance_count(Token tok);
void kr_push_token(void* kinds, void* lexemes, void* lines, void* cols, Token tok);
Lexer kr_advance_n(Lexer lex, int64_t n);
int64_t kr_tokenize(kr_str source, void* int_data, void* lexemes);
int64_t kr_NODE_MODULE();
int64_t kr_NODE_IMPORT();
int64_t kr_NODE_VAR_DECL();
int64_t kr_NODE_CONST_DECL();
int64_t kr_NODE_FN_DECL();
int64_t kr_NODE_STRUCT_DECL();
int64_t kr_NODE_ENUM_DECL();
int64_t kr_NODE_TRAIT_DECL();
int64_t kr_NODE_IMPL_BLOCK();
int64_t kr_NODE_TRAIT_IMPL();
int64_t kr_NODE_TYPE_ALIAS();
int64_t kr_NODE_RETURN();
int64_t kr_NODE_IF();
int64_t kr_NODE_WHILE();
int64_t kr_NODE_FOR();
int64_t kr_NODE_FOR_IN();
int64_t kr_NODE_MATCH();
int64_t kr_NODE_BREAK();
int64_t kr_NODE_CONTINUE();
int64_t kr_NODE_DEFER();
int64_t kr_NODE_UNSAFE();
int64_t kr_NODE_EXPRESSION();
int64_t kr_NODE_CLASS_DECL();
int64_t kr_NODE_INTERFACE_DECL();
int64_t kr_NODE_UNION_DECL();
int64_t kr_NODE_MACRO_DECL();
int64_t kr_NODE_STATIC_ASSERT();
int64_t kr_NODE_ATTRIBUTE();
int64_t kr_EXPR_INT_LIT();
int64_t kr_EXPR_FLOAT_LIT();
int64_t kr_EXPR_STRING_LIT();
int64_t kr_EXPR_BOOL_LIT();
int64_t kr_EXPR_NULL_LIT();
int64_t kr_EXPR_IDENTIFIER();
int64_t kr_EXPR_BINARY();
int64_t kr_EXPR_UNARY();
int64_t kr_EXPR_CALL();
int64_t kr_EXPR_ARRAY();
int64_t kr_EXPR_INDEX();
int64_t kr_EXPR_MEMBER();
int64_t kr_EXPR_STRUCT_LIT();
int64_t kr_EXPR_ASSIGNMENT();
int64_t kr_EXPR_REFERENCE();
int64_t kr_EXPR_DEREF();
int64_t kr_EXPR_ENUM_VARIANT();
int64_t kr_EXPR_TUPLE();
int64_t kr_EXPR_RANGE();
int64_t kr_EXPR_CLOSURE();
int64_t kr_EXPR_AWAIT();
int64_t kr_EXPR_SPAWN();
int64_t kr_EXPR_TRY();
int64_t kr_EXPR_SLICE();
int64_t kr_TYPE_INT();
int64_t kr_TYPE_FLOAT();
int64_t kr_TYPE_BOOL();
int64_t kr_TYPE_STRING();
int64_t kr_TYPE_STR();
int64_t kr_TYPE_BYTES();
int64_t kr_TYPE_VOID();
int64_t kr_TYPE_CUSTOM();
int64_t kr_TYPE_ARRAY();
int64_t kr_TYPE_REFERENCE();
int64_t kr_TYPE_POINTER();
int64_t kr_TYPE_TUPLE();
int64_t kr_TYPE_FUNCTION();
int64_t kr_TYPE_GENERIC();
int64_t kr_PAT_LITERAL();
int64_t kr_PAT_IDENTIFIER();
int64_t kr_PAT_WILDCARD();
int64_t kr_PAT_ENUM_VARIANT();
int64_t kr_PAT_TUPLE();
int64_t kr_PAT_RANGE();
int64_t kr_PAT_OR();
int64_t kr_PAT_STRUCT();
int64_t kr_FLAG_PUBLIC();
int64_t kr_FLAG_MUTABLE();
int64_t kr_FLAG_ASYNC();
int64_t kr_FLAG_UNSAFE();
int64_t kr_FLAG_VARIADIC();
int64_t kr_FLAG_REFERENCE();
bool kr_has_flag(AstNode node, int64_t flag);
AstNode kr_new_node(int64_t kind, kr_str name, int64_t line, int64_t column);
AstArena kr_new_arena();
AstArena kr_arena_add(AstArena arena);
TypeNode kr_new_type(int64_t kind, kr_str name);
TypeNode kr_type_from_keyword(int64_t kw);
Parameter kr_new_param(kr_str name, int64_t type_kind, kr_str type_name);
Field kr_new_field(kr_str name, int64_t type_kind, kr_str type_name);
MatchArm kr_new_match_arm(int64_t pattern_kind, kr_str pattern_value);
kr_str kr_node_kind_name(int64_t kind);
Translator kr_new_translator(int64_t token_count, kr_str file, void* id, void* lex, void* o);
bool kr_tr_at_end(Translator tr);
int64_t kr_tr_kind(Translator tr);
kr_str kr_tr_lexeme(Translator tr);
int64_t kr_tr_line(Translator tr);
int64_t kr_tr_col(Translator tr);
Translator kr_tr_advance(Translator tr);
Translator kr_tr_skip(Translator tr, int64_t n);
Translator kr_tr_indent(Translator tr);
Translator kr_tr_dedent(Translator tr);
Translator kr_tr_reset_pos(Translator tr);
Translator kr_tr_error(Translator tr, kr_str msg);
void kr_tr_emit(Translator tr, kr_str s);
void kr_tr_emit_indent(Translator tr);
void kr_tr_emit_line(Translator tr, kr_str s);
kr_str kr_type_to_c(int64_t kind, kr_str name);
kr_str kr_type_to_c_value(int64_t kind);
Translator kr_skip_generic_params(Translator tr);
kr_str kr_sanitize_c_name(kr_str name);
TranslateResult kr_translate(void* int_data, void* lexemes, int64_t token_count, kr_str file, Target target, void* out);
Translator kr_emit_forward_decls(Translator tr);
Translator kr_emit_fn_prototype(Translator tr);
Translator kr_emit_impl_prototypes(Translator tr);
Translator kr_skip_brace_block(Translator tr);
Translator kr_translate_program(Translator tr);
Translator kr_translate_top_level(Translator tr);
Translator kr_translate_impl(Translator tr);
Translator kr_translate_impl_fn(Translator tr, kr_str type_name);
Translator kr_translate_type_alias(Translator tr);
Translator kr_translate_const_decl(Translator tr);
Translator kr_translate_enum(Translator tr);
Translator kr_translate_struct(Translator tr);
Translator kr_translate_fn(Translator tr);
Translator kr_translate_block_body(Translator tr);
Translator kr_skip_to_sync(Translator tr);
Translator kr_translate_statement(Translator tr);
Translator kr_translate_var_decl(Translator tr);
Translator kr_translate_return(Translator tr);
Translator kr_translate_if(Translator tr);
Translator kr_translate_while(Translator tr);
Translator kr_translate_for(Translator tr);
Translator kr_translate_match(Translator tr);
Translator kr_translate_match_simple(Translator tr);
Translator kr_translate_for_in(Translator tr, kr_str vname);
Translator kr_translate_expr_stmt(Translator tr);
Translator kr_translate_expr(Translator tr);
Translator kr_translate_or(Translator tr);
Translator kr_translate_and(Translator tr);
Translator kr_translate_bit_or(Translator tr);
Translator kr_translate_bit_xor(Translator tr);
Translator kr_translate_bit_and(Translator tr);
int64_t kr_scan_eq_ahead(Translator tr);
Translator kr_translate_equality(Translator tr);
Translator kr_translate_comparison(Translator tr);
Translator kr_translate_shift(Translator tr);
Translator kr_translate_addition(Translator tr);
Translator kr_translate_multiplication(Translator tr);
Translator kr_translate_unary(Translator tr);
Translator kr_translate_postfix(Translator tr);
Translator kr_translate_primary(Translator tr);
kr_str kr_join_output(void* out);
kr_str kr_emit_binary_op(int64_t op);
kr_str kr_emit_unary_op(int64_t op);
kr_str kr_make_indent(int64_t level);
kr_str kr_mangle_name(kr_str mod_name, kr_str name);
kr_str kr_mangle_struct(kr_str name);
kr_str kr_mangle_enum(kr_str name);
int64_t kr_SEV_ERROR();
int64_t kr_SEV_WARNING();
int64_t kr_SEV_INFO();
int64_t kr_SEV_HINT();
Diagnostic kr_new_error(kr_str code, kr_str message, kr_str file, int64_t line, int64_t column);
Diagnostic kr_new_warning(kr_str code, kr_str message, kr_str file, int64_t line, int64_t column);
Diagnostic kr_with_hint(Diagnostic d, kr_str hint);
kr_str kr_KRA_UNEXPECTED_CHAR();
kr_str kr_KRA_UNTERMINATED_STR();
kr_str kr_KRA_EXPECTED_TOKEN();
kr_str kr_KRA_UNEXPECTED_TOKEN();
kr_str kr_KRA_TYPE_MISMATCH();
kr_str kr_KRA_UNDEFINED_VAR();
kr_str kr_KRA_DUPLICATE_DECL();
kr_str kr_KRA_MISSING_RETURN();
kr_str kr_KRA_INVALID_ASSIGN();
kr_str kr_KRA_UNKNOWN_TYPE();
kr_str kr_KRA_ARG_COUNT();
kr_str kr_KRA_UNREACHABLE();
kr_str kr_KRA_CODEGEN_FAIL();
kr_str kr_KRA_IO_ERROR();
kr_str kr_severity_label(int64_t severity);
kr_str kr_format_diagnostic(Diagnostic d);
void kr_print_diagnostic(Diagnostic d);
int64_t kr_OS_UNKNOWN();
int64_t kr_OS_LINUX();
int64_t kr_OS_MACOS();
int64_t kr_OS_WINDOWS();
int64_t kr_OS_FREEBSD();
int64_t kr_OS_WASI();
kr_str kr_os_name(int64_t os);
kr_str kr_os_display_name(int64_t os);
bool kr_os_is_posix(int64_t os);
bool kr_os_is_windows(int64_t os);
int64_t kr_ARCH_UNKNOWN();
int64_t kr_ARCH_X86_64();
int64_t kr_ARCH_AARCH64();
int64_t kr_ARCH_ARM();
int64_t kr_ARCH_RISCV64();
int64_t kr_ARCH_WASM32();
kr_str kr_arch_name(int64_t arch);
int64_t kr_arch_pointer_width(int64_t arch);
bool kr_arch_is_64bit(int64_t arch);
int64_t kr_ABI_UNKNOWN();
int64_t kr_ABI_GNU();
int64_t kr_ABI_MSVC();
int64_t kr_ABI_MUSL();
int64_t kr_ABI_NONE();
kr_str kr_abi_name(int64_t abi);
Target kr_parse_target(kr_str triple);
Target kr_new_target(int64_t os, int64_t arch, int64_t abi, kr_str vendor, kr_str triple);
Target kr_detect_host_target();
bool kr_target_is_valid(Target t);
kr_str kr_format_target(Target t);
kr_str kr_format_target_display(Target t);
kr_str kr_default_cc(Target t);
kr_str kr_cc_cross_flags(Target t);
kr_str kr_c_includes_posix();
kr_str kr_c_includes_windows();
kr_str kr_c_includes_wasi();
kr_str kr_c_includes_for_target(Target t);
kr_str kr_c_typedefs_common();
kr_str kr_c_size_type(Target t);
kr_str kr_c_runtime_shims_posix();
kr_str kr_c_runtime_shims_windows();
kr_str kr_c_runtime_shims_wasi();
kr_str kr_c_runtime_shims_for_target(Target t);
kr_str kr_c_main_signature(Target t);
kr_str kr_linker_flags(Target t);
kr_str kr_object_ext(Target t);
kr_str kr_exe_ext(Target t);
kr_str kr_emit_c_preamble(Target t);
void kr_print_supported_targets();
kr_str kr_COMPILER_VERSION();
kr_str kr_COMPILER_NAME();
int64_t kr_MODE_COMPILE();
int64_t kr_MODE_EMIT_C();
int64_t kr_MODE_TOKENS();
int64_t kr_MODE_VERSION();
int64_t kr_MODE_HELP();
int64_t kr_MODE_TARGETS();
void kr_print_banner();
void kr_print_version();
void kr_print_help();
kr_str kr_dir_of(kr_str path);
kr_str kr_resolve_imports(kr_str source, kr_str source_dir);
kr_str kr_derive_c_path(kr_str input);
kr_str kr_derive_exe_path(kr_str input, Target target);
void kr_dump_tokens(void* int_data, void* lexemes, int64_t count);
int64_t kr_main();

struct SourceLocation {
int64_t line;
int64_t column;
int64_t offset;
};

struct Token {
int64_t kind;
kr_str lexeme;
int64_t line;
int64_t column;
};

struct Lexer {
kr_str source;
int64_t pos;
int64_t line;
int64_t column;
int64_t length;
};

struct AstNode {
int64_t kind;
kr_str name;
kr_str str_value;
int64_t int_value;
int64_t line;
int64_t column;
int64_t flags;
int64_t parent_id;
int64_t first_child;
int64_t next_sibling;
};

struct AstArena {
int64_t count;
};

struct TypeNode {
int64_t kind;
kr_str name;
bool is_mutable;
};

struct Parameter {
kr_str name;
int64_t type_kind;
kr_str type_name;
bool is_reference;
};

struct Field {
kr_str name;
int64_t type_kind;
kr_str type_name;
bool is_public;
};

struct MatchArm {
int64_t pattern_kind;
kr_str pattern_value;
int64_t body_start;
int64_t body_count;
};

struct Translator {
int64_t pos;
int64_t count;
int64_t indent;
int64_t errors;
kr_str file;
void* int_data;
void* lexemes;
void* out;
};

struct TranslateResult {
int64_t errors;
bool success;
};

struct Diagnostic {
int64_t severity;
kr_str code;
kr_str message;
kr_str file;
int64_t line;
int64_t column;
kr_str hint;
};

struct Target {
int64_t os;
int64_t arch;
int64_t abi;
kr_str vendor;
kr_str triple;
};

SourceLocation kr_new_location(int64_t line, int64_t column, int64_t offset) {
    return (SourceLocation){.line = line, .column = column, .offset = offset};
}

Token kr_new_token(int64_t kind, kr_str lexeme, int64_t line, int64_t column) {
    return (Token){.kind = kind, .lexeme = lexeme, .line = line, .column = column};
}

int64_t kr_TK_INT_LIT() {
    return 1;
}

int64_t kr_TK_FLOAT_LIT() {
    return 2;
}

int64_t kr_TK_STRING_LIT() {
    return 3;
}

int64_t kr_TK_BOOL_LIT() {
    return 4;
}

int64_t kr_TK_IDENTIFIER() {
    return 10;
}

int64_t kr_TK_KW_IF() {
    return 100;
}

int64_t kr_TK_KW_ELSE() {
    return 101;
}

int64_t kr_TK_KW_MATCH() {
    return 102;
}

int64_t kr_TK_KW_FOR() {
    return 103;
}

int64_t kr_TK_KW_WHILE() {
    return 104;
}

int64_t kr_TK_KW_DO() {
    return 105;
}

int64_t kr_TK_KW_BREAK() {
    return 106;
}

int64_t kr_TK_KW_CONTINUE() {
    return 107;
}

int64_t kr_TK_KW_RETURN() {
    return 108;
}

int64_t kr_TK_KW_FN() {
    return 109;
}

int64_t kr_TK_KW_LET() {
    return 110;
}

int64_t kr_TK_KW_CONST() {
    return 111;
}

int64_t kr_TK_KW_MODULE() {
    return 112;
}

int64_t kr_TK_KW_IMPORT() {
    return 113;
}

int64_t kr_TK_KW_STRUCT() {
    return 114;
}

int64_t kr_TK_KW_ENUM() {
    return 115;
}

int64_t kr_TK_KW_TRAIT() {
    return 116;
}

int64_t kr_TK_KW_IMPL() {
    return 117;
}

int64_t kr_TK_KW_TYPE() {
    return 118;
}

int64_t kr_TK_KW_PUB() {
    return 119;
}

int64_t kr_TK_KW_PRIV() {
    return 120;
}

int64_t kr_TK_KW_STATIC() {
    return 121;
}

int64_t kr_TK_KW_ASYNC() {
    return 122;
}

int64_t kr_TK_KW_AWAIT() {
    return 123;
}

int64_t kr_TK_KW_SPAWN() {
    return 124;
}

int64_t kr_TK_KW_REF() {
    return 125;
}

int64_t kr_TK_KW_MUT() {
    return 126;
}

int64_t kr_TK_KW_MOVE() {
    return 127;
}

int64_t kr_TK_KW_UNSAFE() {
    return 128;
}

int64_t kr_TK_KW_TRUE() {
    return 129;
}

int64_t kr_TK_KW_FALSE() {
    return 130;
}

int64_t kr_TK_KW_NULL() {
    return 131;
}

int64_t kr_TK_KW_SELF() {
    return 132;
}

int64_t kr_TK_KW_SUPER() {
    return 133;
}

int64_t kr_TK_KW_DEFER() {
    return 134;
}

int64_t kr_TK_KW_WHERE() {
    return 135;
}

int64_t kr_TK_KW_AS() {
    return 136;
}

int64_t kr_TK_KW_IN() {
    return 137;
}

int64_t kr_TK_KW_DYN() {
    return 138;
}

int64_t kr_TK_KW_UNION() {
    return 139;
}

int64_t kr_TK_KW_CLASS() {
    return 140;
}

int64_t kr_TK_KW_INTERFACE() {
    return 141;
}

int64_t kr_TK_KW_INT() {
    return 150;
}

int64_t kr_TK_KW_FLOAT() {
    return 151;
}

int64_t kr_TK_KW_BOOL() {
    return 152;
}

int64_t kr_TK_KW_STRING() {
    return 153;
}

int64_t kr_TK_KW_STR() {
    return 154;
}

int64_t kr_TK_KW_BYTES() {
    return 155;
}

int64_t kr_TK_KW_VOID() {
    return 156;
}

int64_t kr_TK_OP_PLUS() {
    return 200;
}

int64_t kr_TK_OP_MINUS() {
    return 201;
}

int64_t kr_TK_OP_STAR() {
    return 202;
}

int64_t kr_TK_OP_SLASH() {
    return 203;
}

int64_t kr_TK_OP_PERCENT() {
    return 204;
}

int64_t kr_TK_OP_EQ() {
    return 205;
}

int64_t kr_TK_OP_NEQ() {
    return 206;
}

int64_t kr_TK_OP_LT() {
    return 207;
}

int64_t kr_TK_OP_LTE() {
    return 208;
}

int64_t kr_TK_OP_GT() {
    return 209;
}

int64_t kr_TK_OP_GTE() {
    return 210;
}

int64_t kr_TK_OP_AND() {
    return 211;
}

int64_t kr_TK_OP_OR() {
    return 212;
}

int64_t kr_TK_OP_NOT() {
    return 213;
}

int64_t kr_TK_OP_BIT_AND() {
    return 214;
}

int64_t kr_TK_OP_BIT_OR() {
    return 215;
}

int64_t kr_TK_OP_BIT_XOR() {
    return 216;
}

int64_t kr_TK_OP_BIT_NOT() {
    return 217;
}

int64_t kr_TK_OP_LSHIFT() {
    return 218;
}

int64_t kr_TK_OP_RSHIFT() {
    return 219;
}

int64_t kr_TK_OP_ASSIGN() {
    return 220;
}

int64_t kr_TK_OP_PLUS_ASSIGN() {
    return 221;
}

int64_t kr_TK_OP_MINUS_ASSIGN() {
    return 222;
}

int64_t kr_TK_OP_STAR_ASSIGN() {
    return 223;
}

int64_t kr_TK_OP_SLASH_ASSIGN() {
    return 224;
}

int64_t kr_TK_OP_PERCENT_ASSIGN() {
    return 225;
}

int64_t kr_TK_OP_DOT_DOT() {
    return 226;
}

int64_t kr_TK_OP_DOT_DOT_EQ() {
    return 227;
}

int64_t kr_TK_LPAREN() {
    return 250;
}

int64_t kr_TK_RPAREN() {
    return 251;
}

int64_t kr_TK_LBRACE() {
    return 252;
}

int64_t kr_TK_RBRACE() {
    return 253;
}

int64_t kr_TK_LBRACKET() {
    return 254;
}

int64_t kr_TK_RBRACKET() {
    return 255;
}

int64_t kr_TK_SEMICOLON() {
    return 256;
}

int64_t kr_TK_COMMA() {
    return 257;
}

int64_t kr_TK_DOT() {
    return 258;
}

int64_t kr_TK_COLON() {
    return 259;
}

int64_t kr_TK_COLON_COLON() {
    return 260;
}

int64_t kr_TK_ARROW() {
    return 261;
}

int64_t kr_TK_QUESTION() {
    return 262;
}

int64_t kr_TK_PIPE() {
    return 263;
}

int64_t kr_TK_HASH() {
    return 264;
}

int64_t kr_TK_EOF() {
    return 300;
}

int64_t kr_TK_NEWLINE() {
    return 301;
}

int64_t kr_TK_COMMENT() {
    return 302;
}

int64_t kr_lookup_keyword(kr_str s) {
    if (_KR_EQ(s, "if")) {
        return kr_TK_KW_IF();
    }
    if (_KR_EQ(s, "else")) {
        return kr_TK_KW_ELSE();
    }
    if (_KR_EQ(s, "match")) {
        return kr_TK_KW_MATCH();
    }
    if (_KR_EQ(s, "for")) {
        return kr_TK_KW_FOR();
    }
    if (_KR_EQ(s, "while")) {
        return kr_TK_KW_WHILE();
    }
    if (_KR_EQ(s, "do")) {
        return kr_TK_KW_DO();
    }
    if (_KR_EQ(s, "break")) {
        return kr_TK_KW_BREAK();
    }
    if (_KR_EQ(s, "continue")) {
        return kr_TK_KW_CONTINUE();
    }
    if (_KR_EQ(s, "return")) {
        return kr_TK_KW_RETURN();
    }
    if (_KR_EQ(s, "fn")) {
        return kr_TK_KW_FN();
    }
    if (_KR_EQ(s, "let")) {
        return kr_TK_KW_LET();
    }
    if (_KR_EQ(s, "const")) {
        return kr_TK_KW_CONST();
    }
    if (_KR_EQ(s, "module")) {
        return kr_TK_KW_MODULE();
    }
    if (_KR_EQ(s, "import")) {
        return kr_TK_KW_IMPORT();
    }
    if (_KR_EQ(s, "struct")) {
        return kr_TK_KW_STRUCT();
    }
    if (_KR_EQ(s, "enum")) {
        return kr_TK_KW_ENUM();
    }
    if (_KR_EQ(s, "trait")) {
        return kr_TK_KW_TRAIT();
    }
    if (_KR_EQ(s, "impl")) {
        return kr_TK_KW_IMPL();
    }
    if (_KR_EQ(s, "type")) {
        return kr_TK_KW_TYPE();
    }
    if (_KR_EQ(s, "pub")) {
        return kr_TK_KW_PUB();
    }
    if (_KR_EQ(s, "priv")) {
        return kr_TK_KW_PRIV();
    }
    if (_KR_EQ(s, "static")) {
        return kr_TK_KW_STATIC();
    }
    if (_KR_EQ(s, "async")) {
        return kr_TK_KW_ASYNC();
    }
    if (_KR_EQ(s, "await")) {
        return kr_TK_KW_AWAIT();
    }
    if (_KR_EQ(s, "spawn")) {
        return kr_TK_KW_SPAWN();
    }
    if (_KR_EQ(s, "ref")) {
        return kr_TK_KW_REF();
    }
    if (_KR_EQ(s, "mut")) {
        return kr_TK_KW_MUT();
    }
    if (_KR_EQ(s, "move")) {
        return kr_TK_KW_MOVE();
    }
    if (_KR_EQ(s, "unsafe")) {
        return kr_TK_KW_UNSAFE();
    }
    if (_KR_EQ(s, "true")) {
        return kr_TK_KW_TRUE();
    }
    if (_KR_EQ(s, "false")) {
        return kr_TK_KW_FALSE();
    }
    if (_KR_EQ(s, "null")) {
        return kr_TK_KW_NULL();
    }
    if (_KR_EQ(s, "self")) {
        return kr_TK_KW_SELF();
    }
    if (_KR_EQ(s, "super")) {
        return kr_TK_KW_SUPER();
    }
    if (_KR_EQ(s, "defer")) {
        return kr_TK_KW_DEFER();
    }
    if (_KR_EQ(s, "where")) {
        return kr_TK_KW_WHERE();
    }
    if (_KR_EQ(s, "as")) {
        return kr_TK_KW_AS();
    }
    if (_KR_EQ(s, "in")) {
        return kr_TK_KW_IN();
    }
    if (_KR_EQ(s, "dyn")) {
        return kr_TK_KW_DYN();
    }
    if (_KR_EQ(s, "union")) {
        return kr_TK_KW_UNION();
    }
    if (_KR_EQ(s, "class")) {
        return kr_TK_KW_CLASS();
    }
    if (_KR_EQ(s, "interface")) {
        return kr_TK_KW_INTERFACE();
    }
    if (_KR_EQ(s, "int")) {
        return kr_TK_KW_INT();
    }
    if (_KR_EQ(s, "float")) {
        return kr_TK_KW_FLOAT();
    }
    if (_KR_EQ(s, "bool")) {
        return kr_TK_KW_BOOL();
    }
    if (_KR_EQ(s, "string")) {
        return kr_TK_KW_STRING();
    }
    if (_KR_EQ(s, "str")) {
        return kr_TK_KW_STR();
    }
    if (_KR_EQ(s, "bytes")) {
        return kr_TK_KW_BYTES();
    }
    if (_KR_EQ(s, "void")) {
        return kr_TK_KW_VOID();
    }
    return 0;
}

kr_str kr_token_kind_name(int64_t kind) {
    if (_KR_EQ(kind, kr_TK_INT_LIT())) {
        return "integer literal";
    }
    if (_KR_EQ(kind, kr_TK_FLOAT_LIT())) {
        return "float literal";
    }
    if (_KR_EQ(kind, kr_TK_STRING_LIT())) {
        return "string literal";
    }
    if (_KR_EQ(kind, kr_TK_BOOL_LIT())) {
        return "bool literal";
    }
    if (_KR_EQ(kind, kr_TK_IDENTIFIER())) {
        return "identifier";
    }
    if (_KR_EQ(kind, kr_TK_EOF())) {
        return "end of file";
    }
    if (_KR_EQ(kind, kr_TK_NEWLINE())) {
        return "newline";
    }
    if (_KR_EQ(kind, kr_TK_COMMENT())) {
        return "comment";
    }
    if (kind >= 100) {
        if (kind) {
        }
    }
}


int main(int argc, char* argv[]) {
    kr_main();
    return 0;
}
