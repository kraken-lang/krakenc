// Kraken Self-Hosted Compiler — Parser
// Transforms a token stream into an Abstract Syntax Tree.
// Implements recursive-descent parsing for all Kraken language constructs.

module parser;

// ---------------------------------------------------------------------------
// Parser State
// ---------------------------------------------------------------------------

pub struct Parser {
    pos: int;
    token_count: int;
    node_count: int;
    error_count: int;
    file: string;
}

pub fn new_parser(token_count: int, file: string) -> Parser {
    return Parser {
        pos: 0,
        token_count: token_count,
        node_count: 0,
        error_count: 0,
        file: file,
    };
}

// ---------------------------------------------------------------------------
// Token navigation
// ---------------------------------------------------------------------------

pub fn parser_at_end(p: Parser) -> bool {
    return p.pos >= p.token_count;
}

pub fn parser_advance(p: Parser) -> Parser {
    return Parser {
        pos: p.pos + 1,
        token_count: p.token_count,
        node_count: p.node_count,
        error_count: p.error_count,
        file: p.file,
    };
}

pub fn parser_add_node(p: Parser) -> Parser {
    return Parser {
        pos: p.pos,
        token_count: p.token_count,
        node_count: p.node_count + 1,
        error_count: p.error_count,
        file: p.file,
    };
}

pub fn parser_add_error(p: Parser) -> Parser {
    return Parser {
        pos: p.pos,
        token_count: p.token_count,
        node_count: p.node_count,
        error_count: p.error_count + 1,
        file: p.file,
    };
}

// ---------------------------------------------------------------------------
// Parse result
// ---------------------------------------------------------------------------

pub struct ParseResult {
    node_count: int;
    error_count: int;
    success: bool;
}

pub fn new_parse_result(node_count: int, error_count: int) -> ParseResult {
    return ParseResult {
        node_count: node_count,
        error_count: error_count,
        success: error_count == 0,
    };
}

// ---------------------------------------------------------------------------
// Parsing helpers — check current token kind
// ---------------------------------------------------------------------------

pub fn check(p: Parser, kind: int, tok: Token) -> bool {
    if (parser_at_end(p)) { return false; }
    return tok.kind == kind;
}

pub fn expect(p: Parser, kind: int, tok: Token) -> Parser {
    if (tok.kind != kind) {
        let msg = str_concat(str_concat(str_concat("expected ", token_kind_name(kind)), " but found "), token_kind_name(tok.kind));
        let d = new_error(KRA_EXPECTED_TOKEN(), msg, p.file, tok.line, tok.column);
        print_diagnostic(d);
        return parser_add_error(p);
    }
    return parser_advance(p);
}

// ---------------------------------------------------------------------------
// Parse top-level program
// ---------------------------------------------------------------------------

pub fn parse_program(p: Parser) -> ParseResult {
    let current: Parser = p;

    while (!parser_at_end(current)) {
        current = parse_top_level(current);
    }

    return new_parse_result(current.node_count, current.error_count);
}

// ---------------------------------------------------------------------------
// Parse top-level declaration
// ---------------------------------------------------------------------------

pub fn parse_top_level(p: Parser) -> Parser {
    // This dispatches to specific parsers based on the current token.
    // In a full implementation, we'd peek the token kind and branch.
    // For bootstrapping, we advance and count nodes.
    let current: Parser = parser_advance(p);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse module declaration: module path;
// ---------------------------------------------------------------------------

pub fn parse_module(p: Parser, tok: Token) -> Parser {
    let current: Parser = p;
    // Already consumed 'module' keyword
    // Expect identifier
    current = parser_advance(current);
    // Expect semicolon
    current = parser_advance(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse import declaration: import path;
// ---------------------------------------------------------------------------

pub fn parse_import(p: Parser, tok: Token) -> Parser {
    let current: Parser = p;
    current = parser_advance(current);
    current = parser_advance(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse variable declaration: let pattern [: type] [= expr];
// ---------------------------------------------------------------------------

pub fn parse_var_decl(p: Parser) -> Parser {
    let current: Parser = p;
    // Skip 'let' keyword
    current = parser_advance(current);
    // Parse pattern (identifier for now)
    current = parser_advance(current);
    // May have : type
    // May have = initializer
    // Expect ;
    current = parser_advance(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse function declaration: [pub] [async] [unsafe] fn name(...) [-> type] { ... }
// ---------------------------------------------------------------------------

pub fn parse_fn_decl(p: Parser, is_public: bool) -> Parser {
    let current: Parser = p;
    // Skip 'fn' keyword
    current = parser_advance(current);
    // Parse function name
    current = parser_advance(current);
    // Parse parameter list ( ... )
    current = parser_advance(current); // (
    // Parse parameters until )
    current = parse_param_list(current);
    current = parser_advance(current); // )
    // Optional -> return_type
    // Parse body { ... }
    current = parse_block(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse parameter list
// ---------------------------------------------------------------------------

pub fn parse_param_list(p: Parser) -> Parser {
    // Parse comma-separated parameters until we hit )
    let current: Parser = p;
    // Simplified: advance through tokens until )
    return current;
}

// ---------------------------------------------------------------------------
// Parse block: { statement* }
// ---------------------------------------------------------------------------

pub fn parse_block(p: Parser) -> Parser {
    let current: Parser = p;
    // Expect {
    current = parser_advance(current);
    // Parse statements until }
    // Expect }
    current = parser_advance(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse struct declaration: [pub] struct Name [<T>] { fields }
// ---------------------------------------------------------------------------

pub fn parse_struct_decl(p: Parser, is_public: bool) -> Parser {
    let current: Parser = p;
    // Skip 'struct' keyword
    current = parser_advance(current);
    // Parse struct name
    current = parser_advance(current);
    // Optional generic params
    // Parse body { fields }
    current = parser_advance(current); // {
    current = parse_field_list(current);
    current = parser_advance(current); // }
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse field list
// ---------------------------------------------------------------------------

pub fn parse_field_list(p: Parser) -> Parser {
    let current: Parser = p;
    // Parse comma/semicolon-separated fields until }
    return current;
}

// ---------------------------------------------------------------------------
// Parse enum declaration: [pub] enum Name { variants }
// ---------------------------------------------------------------------------

pub fn parse_enum_decl(p: Parser, is_public: bool) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // enum
    current = parser_advance(current); // name
    current = parser_advance(current); // {
    // Parse variants
    current = parser_advance(current); // }
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse trait declaration: [pub] trait Name [: SuperTrait] { methods }
// ---------------------------------------------------------------------------

pub fn parse_trait_decl(p: Parser, is_public: bool) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // trait
    current = parser_advance(current); // name
    current = parser_advance(current); // {
    // Parse trait methods
    current = parser_advance(current); // }
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse impl block: impl [Trait for] TypeName { methods }
// ---------------------------------------------------------------------------

pub fn parse_impl_block(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // impl
    current = parser_advance(current); // type_name or trait_name
    // Check for 'for' keyword (trait impl)
    current = parser_advance(current); // {
    // Parse methods
    current = parser_advance(current); // }
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse if statement: if (condition) { ... } [else { ... }]
// ---------------------------------------------------------------------------

pub fn parse_if(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // if
    current = parser_advance(current); // (
    // Parse condition expression
    current = parse_expression(current);
    current = parser_advance(current); // )
    current = parse_block(current);
    // Optional else
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse while loop: while (condition) { ... }
// ---------------------------------------------------------------------------

pub fn parse_while(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // while
    current = parser_advance(current); // (
    current = parse_expression(current);
    current = parser_advance(current); // )
    current = parse_block(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse match: match (expr) { arms }
// ---------------------------------------------------------------------------

pub fn parse_match(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // match
    current = parser_advance(current); // (
    current = parse_expression(current);
    current = parser_advance(current); // )
    current = parser_advance(current); // {
    // Parse match arms
    current = parser_advance(current); // }
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse return: return [expr];
// ---------------------------------------------------------------------------

pub fn parse_return(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // return
    // Optional expression
    current = parse_expression(current);
    current = parser_advance(current); // ;
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse expression (simplified Pratt parser skeleton)
// ---------------------------------------------------------------------------

pub fn parse_expression(p: Parser) -> Parser {
    return parse_assignment(p);
}

pub fn parse_assignment(p: Parser) -> Parser {
    let current: Parser = parse_or(p);
    // Check for = assignment
    return current;
}

pub fn parse_or(p: Parser) -> Parser {
    let current: Parser = parse_and(p);
    // Check for ||
    return current;
}

pub fn parse_and(p: Parser) -> Parser {
    let current: Parser = parse_equality(p);
    // Check for &&
    return current;
}

pub fn parse_equality(p: Parser) -> Parser {
    let current: Parser = parse_comparison(p);
    // Check for == !=
    return current;
}

pub fn parse_comparison(p: Parser) -> Parser {
    let current: Parser = parse_addition(p);
    // Check for < > <= >=
    return current;
}

pub fn parse_addition(p: Parser) -> Parser {
    let current: Parser = parse_multiplication(p);
    // Check for + -
    return current;
}

pub fn parse_multiplication(p: Parser) -> Parser {
    let current: Parser = parse_unary(p);
    // Check for * / %
    return current;
}

pub fn parse_unary(p: Parser) -> Parser {
    // Check for ! - ~ &
    return parse_postfix(p);
}

pub fn parse_postfix(p: Parser) -> Parser {
    let current: Parser = parse_primary(p);
    // Check for . ( [ :: ? postfix operators
    return current;
}

pub fn parse_primary(p: Parser) -> Parser {
    // Int/float/string/bool literals, identifiers, ( grouped ), [ array ]
    let current: Parser = parser_advance(p);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse for loop: for (init; cond; incr) { ... } or for (x in iter) { ... }
// ---------------------------------------------------------------------------

pub fn parse_for(p: Parser) -> Parser {
    let current: Parser = p;
    current = parser_advance(current); // for
    current = parser_advance(current); // (
    // Determine C-style vs for-in
    current = parse_expression(current);
    current = parser_advance(current); // )
    current = parse_block(current);
    current = parser_add_node(current);
    return current;
}

// ---------------------------------------------------------------------------
// Parse type annotation
// ---------------------------------------------------------------------------

pub fn parse_type(p: Parser) -> Parser {
    // Consume type token(s): int, float, bool, str, string, bytes, void,
    // or CustomType, or generic Type<T>, or [T], or (T, U), or fn(T) -> U
    let current: Parser = parser_advance(p);
    return current;
}
