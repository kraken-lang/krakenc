// Kraken Self-Hosted Compiler — Parser / Translator
// Single-pass recursive descent: reads tokens from SOA arrays, emits C code
// into a VecString output buffer. Handles the Kraken language subset needed
// for bootstrapping: functions, structs, variables, control flow, expressions.

module parser;

// ---------------------------------------------------------------------------
// Translator State
// ---------------------------------------------------------------------------

pub struct Translator {
    pos: int;
    count: int;
    indent: int;
    errors: int;
    file: string;
    int_data: VecInt;
    lexemes: VecString;
    out: VecString;
}

fn block_has_unsafe_like(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && vec_string_get(tr.lexemes, i) == "unsafe") { return true; }
        i = i + 1;
    }
    return false;
}

fn block_has_turbofish_like(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i + 1 < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && k == TK_COLON_COLON() && vec_int_get(tr.int_data, (i + 1) * 3) == TK_OP_LT()) { return true; }
        i = i + 1;
    }
    return false;
}

fn block_has_try_like(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && (k == TK_QUESTION() || vec_string_get(tr.lexemes, i) == "?")) { return true; }
        i = i + 1;
    }
    return false;
}

fn block_has_self_init_let(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i + 3 < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && k == TK_KW_LET()) {
            let n1 = i + 1;
            let n2 = i + 2;
            let n3 = i + 3;
            if (n3 < tr.count) {
                if (vec_int_get(tr.int_data, n1 * 3) == TK_IDENTIFIER() && vec_int_get(tr.int_data, n2 * 3) == TK_OP_ASSIGN() && vec_int_get(tr.int_data, n3 * 3) == TK_IDENTIFIER()) {
                    if (vec_string_get(tr.lexemes, n1) == vec_string_get(tr.lexemes, n3)) { return true; }
                }
            }
        }
        i = i + 1;
    }
    return false;
}

fn translate_union(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let name = tr_lexeme(c);
    c = tr_advance(c);
    c = skip_generic_params(c);
    c = tr_advance(c);

    tr_emit_line(c, str_concat("union ", str_concat(name, " {")));
    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        let fname = tr_lexeme(c);
        c = tr_advance(c);
        if (tr_at_end(c)) { break; }
        if (tr_kind(c) != TK_COLON()) {
            if (tr_kind(c) == TK_RBRACE()) { break; }
            c = tr_advance(c);
            continue;
        }
        c = tr_advance(c);
        let fk = tr_kind(c); let fn_name = tr_lexeme(c); c = tr_advance(c);
        if (fk == TK_OP_STAR() && !tr_at_end(c)) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, fk);
        c = skip_generic_params(c);
        let fc = type_to_c(fk, fn_name);
        if (fk == TK_IDENTIFIER()) { fc = "int64_t"; }
        if (fk == TK_KW_FN()) { fc = "void*"; c = skip_fn_type_sig(c); }
        tr_emit_line(c, str_concat(fc, str_concat(" ", str_concat(fname, ";"))));
        if (!tr_at_end(c) && (tr_kind(c) == TK_SEMICOLON() || tr_kind(c) == TK_COMMA())) { c = tr_advance(c); }
    }
    c = tr_advance(c);
    tr_emit_line(c, "};");
    tr_emit(c, "\n");
    return c;
}

// Detect tuple-heavy syntax patterns that do not lower reliably in compatibility mode:
//   - tuple numeric field access: x.0, x.1, ...
//   - tuple-pattern assignment: (a, b) = expr
fn block_has_tuple_like(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }

        if (depth > 0 && k == TK_DOT()) {
            let j = i + 1;
            if (j < tr.count && vec_int_get(tr.int_data, j * 3) == TK_INT_LIT()) { return true; }
        }

        if (depth > 0 && k == TK_LPAREN()) {
            let j2 = i + 1;
            let pdepth = 1;
            let has_comma = 0;
            while (j2 < tr.count && pdepth > 0) {
                let k2 = vec_int_get(tr.int_data, j2 * 3);
                if (k2 == TK_LPAREN()) { pdepth = pdepth + 1; }
                if (k2 == TK_RPAREN()) { pdepth = pdepth - 1; }
                if (pdepth == 1 && k2 == TK_COMMA()) { has_comma = 1; }
                j2 = j2 + 1;
            }
            if (has_comma == 1 && j2 < tr.count) {
                let ak = vec_int_get(tr.int_data, j2 * 3);
                if (ak == TK_OP_ASSIGN() || ak == TK_OP_PLUS_ASSIGN() || ak == TK_OP_MINUS_ASSIGN()
                    || ak == TK_OP_STAR_ASSIGN() || ak == TK_OP_SLASH_ASSIGN() || ak == TK_OP_PERCENT_ASSIGN()) {
                    return true;
                }
            }
        }

        i = i + 1;
    }
    return false;
}

pub fn new_translator(token_count: int, file: string, id: VecInt, lex: VecString, o: VecString) -> Translator {
    return Translator {
        pos: 0,
        count: token_count,
        indent: 0,
        errors: 0,
        file: file,
        int_data: id,
        lexemes: lex,
        out: o,
    };
}

// ---------------------------------------------------------------------------
// Token access helpers — all read from embedded vecs via single Translator
// ---------------------------------------------------------------------------

fn tr_at_end(tr: Translator) -> bool {
    return tr.pos >= tr.count;
}

fn tr_kind(tr: Translator) -> int {
    if (tr_at_end(tr)) { return TK_EOF(); }
    return vec_int_get(tr.int_data, tr.pos * 3);
}

fn tr_lexeme(tr: Translator) -> string {
    if (tr_at_end(tr)) { return ""; }
    return vec_string_get(tr.lexemes, tr.pos);
}

fn tr_line(tr: Translator) -> int {
    if (tr_at_end(tr)) { return 0; }
    return vec_int_get(tr.int_data, tr.pos * 3 + 1);
}

fn tr_col(tr: Translator) -> int {
    if (tr_at_end(tr)) { return 0; }
    return vec_int_get(tr.int_data, tr.pos * 3 + 2);
}

fn tr_advance(tr: Translator) -> Translator {
    return Translator {
        pos: tr.pos + 1, count: tr.count, indent: tr.indent, errors: tr.errors,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

fn tr_skip(tr: Translator, n: int) -> Translator {
    return Translator {
        pos: tr.pos + n, count: tr.count, indent: tr.indent, errors: tr.errors,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

fn tr_indent(tr: Translator) -> Translator {
    return Translator {
        pos: tr.pos, count: tr.count, indent: tr.indent + 1, errors: tr.errors,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

fn tr_dedent(tr: Translator) -> Translator {
    let new_i = tr.indent - 1;
    if (new_i < 0) { new_i = 0; }
    return Translator {
        pos: tr.pos, count: tr.count, indent: new_i, errors: tr.errors,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

fn tr_reset_pos(tr: Translator) -> Translator {
    return Translator {
        pos: 0, count: tr.count, indent: 0, errors: tr.errors,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

fn tr_error(tr: Translator, msg: string) -> Translator {
    let ln = tr_line(tr);
    let co = tr_col(tr);
    let d = new_error(KRA_UNEXPECTED_TOKEN(), msg, tr.file, ln, co);
    print_diagnostic(d);
    return Translator {
        pos: tr.pos, count: tr.count, indent: tr.indent, errors: tr.errors + 1,
        file: tr.file, int_data: tr.int_data, lexemes: tr.lexemes, out: tr.out,
    };
}

// ---------------------------------------------------------------------------
// Output helpers — emit to tr.out
// ---------------------------------------------------------------------------

fn tr_emit(tr: Translator, s: string) -> void {
    vec_string_push(tr.out, s);
}

fn tr_emit_indent(tr: Translator) -> void {
    let i = 0;
    while (i < tr.indent) {
        vec_string_push(tr.out, "    ");
        i = i + 1;
    }
}

fn tr_emit_line(tr: Translator, s: string) -> void {
    tr_emit_indent(tr);
    vec_string_push(tr.out, s);
    vec_string_push(tr.out, "\n");
}

// ---------------------------------------------------------------------------
// Kraken type -> C type mapping
// ---------------------------------------------------------------------------

fn type_to_c(kind: int, name: string) -> string {
    if (kind == TK_KW_INT())    { return "int64_t"; }
    if (kind == TK_KW_FLOAT())  { return "double"; }
    if (kind == TK_KW_BOOL())   { return "bool"; }
    if (kind == TK_KW_STRING()) { return "kr_str"; }
    if (kind == TK_KW_STR())    { return "kr_str"; }
    if (kind == TK_KW_BYTES())  { return "uint8_t*"; }
    if (kind == TK_KW_VOID())   { return "void"; }
    if (kind == TK_IDENTIFIER()) {
        // Generic type params / trait self type (erased in C backend)
        if (strcmp(name, "T") == 0 || strcmp(name, "U") == 0 || strcmp(name, "V") == 0 || strcmp(name, "K") == 0 || strcmp(name, "R") == 0) {
            return "int64_t";
        }
        if (strcmp(name, "Self") == 0) { return "void*"; }
        // Opaque runtime handles
        if (strcmp(name, "VecInt") == 0)    { return "void*"; }
        if (strcmp(name, "VecString") == 0) { return "void*"; }
        if (strcmp(name, "VecBytes") == 0)  { return "void*"; }
        if (strcmp(name, "Vec") == 0)       { return "void*"; }
        if (strcmp(name, "Map") == 0)       { return "void*"; }
        if (strcmp(name, "MapStringInt") == 0)    { return "void*"; }
        if (strcmp(name, "MapStringString") == 0) { return "void*"; }
        // User-defined struct — pass by value (typedef'd name)
        return name;
    }
    return "void*";
}

fn type_to_c_value(kind: int) -> string {
    if (kind == TK_KW_INT())    { return "0"; }
    if (kind == TK_KW_FLOAT())  { return "0.0"; }
    if (kind == TK_KW_BOOL())   { return "false"; }
    if (kind == TK_KW_STRING()) { return "\"\""; }
    if (kind == TK_KW_STR())    { return "\"\""; }
    return "NULL";
}

fn skip_generic_params(tr: Translator) -> Translator {
    let c: Translator = tr;
    if (tr_at_end(c) || tr_kind(c) != TK_OP_LT()) { return c; }
    c = tr_advance(c);
    let depth = 1;
    while (!tr_at_end(c) && depth > 0) {
        if (tr_kind(c) == TK_OP_LT()) { depth = depth + 1; }
        if (tr_kind(c) == TK_OP_GT()) { depth = depth - 1; }
        c = tr_advance(c);
    }
    return c;
}

// Skip array-style type annotation suffix when type starts with '[':
//   [T], [[T]], [(A, B)], ...
fn skip_array_type_suffix(tr: Translator, first_kind: int) -> Translator {
    let c: Translator = tr;
    if (first_kind != TK_LBRACKET()) { return c; }
    let depth = 1;
    while (!tr_at_end(c) && depth > 0) {
        let k = tr_kind(c);
        if (k == TK_LBRACKET()) { depth = depth + 1; }
        if (k == TK_RBRACKET()) { depth = depth - 1; }
        c = tr_advance(c);
    }
    return c;
}

// Detect closure-like syntax patterns in a brace block:
//   |...| -> ...    or    || -> ...
fn block_has_closure_like(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }

        if (depth > 0 && (k == TK_PIPE() || k == TK_OP_BIT_OR() || k == TK_OP_OR())) {
            let prev_k = 0;
            if (i > 0) { prev_k = vec_int_get(tr.int_data, (i - 1) * 3); }
            // Shorthand closure forms in assignment/argument position:
            //   let f = || expr;
            //   let f = |x| expr;
            if (prev_k == TK_OP_ASSIGN() || prev_k == TK_COMMA() || prev_k == TK_LPAREN() || prev_k == TK_ARROW()) {
                return true;
            }
            let j = i + 1;
            let lim = i + 10;
            let saw_lbrace = 0;
            while (j < tr.count && j < lim) {
                let k2 = vec_int_get(tr.int_data, j * 3);
                if (k2 == TK_ARROW()) { return true; }
                if (k2 == TK_LBRACE()) { saw_lbrace = 1; break; }
                if (k2 == TK_SEMICOLON() || k2 == TK_LBRACE()) { break; }
                j = j + 1;
            }
            if (saw_lbrace == 1) { return true; }
        }

        i = i + 1;
    }
    return false;
}

fn block_has_nested_type_decl(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && (k == TK_KW_STRUCT() || k == TK_KW_UNION() || k == TK_KW_ENUM() || k == TK_KW_TRAIT() || k == TK_KW_IMPL() || k == TK_KW_TYPE())) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Detect nested function declarations inside a brace block.
fn block_has_nested_fn(tr: Translator) -> bool {
    if (tr_at_end(tr) || tr_kind(tr) != TK_LBRACE()) { return false; }
    let i = tr.pos + 1;
    let depth = 1;
    while (i < tr.count && depth > 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        if (depth > 0 && k == TK_KW_FN()) { return true; }
        i = i + 1;
    }
    return false;
}

// Skip function-type suffix in type positions:
//   fn(T1, T2) -> Ret
fn skip_fn_type_sig(tr: Translator) -> Translator {
    let c: Translator = tr;
    if (tr_at_end(c) || tr_kind(c) != TK_LPAREN()) { return c; }

    c = tr_advance(c);
    let depth = 1;
    while (!tr_at_end(c) && depth > 0) {
        if (tr_kind(c) == TK_LPAREN()) { depth = depth + 1; }
        if (tr_kind(c) == TK_RPAREN()) { depth = depth - 1; }
        c = tr_advance(c);
    }

    if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
        c = tr_advance(c);
        c = tr_advance(c);
        c = skip_generic_params(c);
    }
    return c;
}

// Only skip `<...>` when it is turbofish/generic syntax attached to an
// identifier, and the closing `>` is followed by `(` or `{`.
// This avoids mis-parsing comparisons like `kind < 200`.
fn maybe_skip_turbofish(tr: Translator) -> Translator {
    let c: Translator = tr;
    if (tr_at_end(c) || tr_kind(c) != TK_OP_LT()) { return c; }

    let i = c.pos;
    let depth = 0;
    while (i < c.count) {
        let k = vec_int_get(c.int_data, i * 3);
        if (k == TK_OP_LT()) { depth = depth + 1; }
        if (k == TK_OP_GT()) {
            depth = depth - 1;
            if (depth == 0) {
                let j = i + 1;
                if (j < c.count) {
                    let k2 = vec_int_get(c.int_data, j * 3);
                    if (k2 == TK_LPAREN() || k2 == TK_LBRACE()) {
                        return skip_generic_params(c);
                    }
                }
                return c;
            }
        }
        i = i + 1;
    }
    return c;
}

fn sanitize_c_name(name: string) -> string {
    if (name == "int")    { return "int_val"; }
    if (name == "float")  { return "float_val"; }
    if (name == "double") { return "double_val"; }
    if (name == "char")   { return "char_val"; }
    if (name == "void")   { return "void_val"; }
    if (name == "long")   { return "long_val"; }
    if (name == "short")  { return "short_val"; }
    if (name == "auto")   { return "auto_val"; }
    if (name == "register") { return "register_val"; }
    if (name == "extern") { return "extern_val"; }
    if (name == "static") { return "static_val"; }
    if (name == "const")  { return "const_val"; }
    if (name == "signed") { return "signed_val"; }
    if (name == "unsigned") { return "unsigned_val"; }
    return name;
}

fn mangle_top_level_fn_name(name: string) -> string {
    if (name == "log") { return "kr_user_log"; }
    return str_concat("kr_", name);
}

// Best-effort local detection for function-typed variables declared as:
//   let name: fn(...) -> ...
fn is_local_fn_var(tr: Translator, name: string) -> bool {
    let i = tr.pos - 1;
    let depth = 0;
    while (i >= 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_RBRACE()) { depth = depth + 1; }
        if (k == TK_LBRACE()) {
            if (depth == 0) { break; }
            depth = depth - 1;
        }
        i = i - 1;
    }

    let start = i + 1;
    let j = start;
    while (j < tr.pos) {
        let k = vec_int_get(tr.int_data, j * 3);
        // Pattern: name: fn(...)  (covers function parameters and typed locals)
        if (vec_string_get(tr.lexemes, j) == name) {
            let j1 = j + 1;
            let j2 = j1 + 1;
            if (j2 < tr.pos) {
                if (vec_int_get(tr.int_data, j1 * 3) == TK_COLON() && vec_int_get(tr.int_data, j2 * 3) == TK_KW_FN()) {
                    return true;
                }
            }
        }
        if (k == TK_KW_LET()) {
            let j1 = j + 1;
            if (j1 < tr.pos && vec_string_get(tr.lexemes, j1) == name) {
                let j2 = j1 + 1;
                let j3 = j2 + 1;
                if (j3 < tr.pos) {
                    if (vec_int_get(tr.int_data, j2 * 3) == TK_COLON() && vec_int_get(tr.int_data, j3 * 3) == TK_KW_FN()) {
                        return true;
                    }
                }

                // Pattern: let name = |...|
                let j4 = j3 + 1;
                if (j4 < tr.pos) {
                    if (vec_int_get(tr.int_data, j2 * 3) == TK_OP_ASSIGN()) {
                        let k_rhs = vec_int_get(tr.int_data, j3 * 3);
                        if (k_rhs == TK_PIPE() || k_rhs == TK_OP_BIT_OR() || k_rhs == TK_OP_OR()) { return true; }
                        // Pattern: let name = some_call(...)
                        if (k_rhs == TK_IDENTIFIER()) {
                            let j5 = j3 + 1;
                            if (j5 < tr.pos && vec_int_get(tr.int_data, j5 * 3) == TK_LPAREN()) {
                                return true;
                            }
                        }
                    }
                    if (vec_int_get(tr.int_data, j3 * 3) == TK_OP_ASSIGN()) {
                        let k_rhs2 = vec_int_get(tr.int_data, j4 * 3);
                        if (k_rhs2 == TK_PIPE() || k_rhs2 == TK_OP_BIT_OR() || k_rhs2 == TK_OP_OR()) { return true; }
                        if (k_rhs2 == TK_IDENTIFIER()) {
                            let j6 = j4 + 1;
                            if (j6 < tr.pos && vec_int_get(tr.int_data, j6 * 3) == TK_LPAREN()) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        j = j + 1;
    }

    // Also check current function parameter list for: name: fn(...)
    let b = start - 1;
    if (b >= 0) {
        let fidx = b;
        while (fidx >= 0 && vec_int_get(tr.int_data, fidx * 3) != TK_KW_FN()) { fidx = fidx - 1; }
        if (fidx >= 0) {
            let p = fidx;
            while (p < start && vec_int_get(tr.int_data, p * 3) != TK_LPAREN()) { p = p + 1; }
            if (p < start && vec_int_get(tr.int_data, p * 3) == TK_LPAREN()) {
                p = p + 1;
                let depthp = 1;
                while (p < start && depthp > 0) {
                    let kp = vec_int_get(tr.int_data, p * 3);
                    if (kp == TK_LPAREN()) { depthp = depthp + 1; }
                    if (kp == TK_RPAREN()) { depthp = depthp - 1; }
                    if (depthp == 1 && vec_string_get(tr.lexemes, p) == name) {
                        let c1 = p + 1;
                        let c2 = c1 + 1;
                        if (c2 < start) {
                            if (vec_int_get(tr.int_data, c1 * 3) == TK_COLON() && vec_int_get(tr.int_data, c2 * 3) == TK_KW_FN()) {
                                return true;
                            }
                        }
                    }
                    p = p + 1;
                }
            }
        }
    }
    return false;
}

// Best-effort local typed-variable lookup for patterns like:
//   let var_name: TypeName = ...
fn lookup_local_var_type_name(tr: Translator, var_name: string) -> string {
    let i = tr.pos - 1;
    let depth = 0;
    while (i >= 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_RBRACE()) { depth = depth + 1; }
        if (k == TK_LBRACE()) {
            if (depth == 0) { break; }
            depth = depth - 1;
        }
        i = i - 1;
    }

    let start = i + 1;
    let j = start;
    while (j < tr.pos) {
        let k = vec_int_get(tr.int_data, j * 3);
        if (k == TK_KW_LET()) {
            let j1 = j + 1;
            if (j1 < tr.pos && vec_string_get(tr.lexemes, j1) == var_name) {
                let j2 = j1 + 1;
                let j3 = j2 + 1;
                if (j3 < tr.pos && vec_int_get(tr.int_data, j2 * 3) == TK_COLON()) {
                    if (vec_string_get(tr.lexemes, j3) == "dyn") {
                        return "dyn";
                    }
                    if (vec_int_get(tr.int_data, j3 * 3) == TK_IDENTIFIER()) {
                        return vec_string_get(tr.lexemes, j3);
                    }
                }
            }
        }
        j = j + 1;
    }
    return "";
}

// Detect whether a top-level function declaration is generic: fn name<...>(...)
fn is_generic_top_level_fn_name(tr: Translator, fn_name: string) -> bool {
    let i = 0;
    while (i + 2 < tr.count) {
        if (vec_int_get(tr.int_data, i * 3) == TK_KW_FN()) {
            let i1 = i + 1;
            if (vec_int_get(tr.int_data, i1 * 3) == TK_IDENTIFIER() && vec_string_get(tr.lexemes, i1) == fn_name) {
                let i2 = i1 + 1;
                if (i2 < tr.count && vec_int_get(tr.int_data, i2 * 3) == TK_OP_LT()) { return true; }
                return false;
            }
        }
        i = i + 1;
    }
    return false;
}

// Best-effort local detection for variables initialized from generic function calls:
//   let x = generic_fn(...);
fn is_local_generic_call_var(tr: Translator, name: string) -> bool {
    let i = tr.pos - 1;
    let depth = 0;
    while (i >= 0) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_RBRACE()) { depth = depth + 1; }
        if (k == TK_LBRACE()) {
            if (depth == 0) { break; }
            depth = depth - 1;
        }
        i = i - 1;
    }

    let start = i + 1;
    let j = start;
    while (j < tr.pos) {
        if (vec_int_get(tr.int_data, j * 3) == TK_KW_LET()) {
            let j1 = j + 1;
            if (j1 < tr.pos && vec_string_get(tr.lexemes, j1) == name) {
                let p = j1 + 1;
                // Skip optional type annotation
                if (p < tr.pos && vec_int_get(tr.int_data, p * 3) == TK_COLON()) {
                    p = p + 1;
                    let pd = 0;
                    let bd = 0;
                    let sd = 0;
                    while (p < tr.pos) {
                        let kk = vec_int_get(tr.int_data, p * 3);
                        if (kk == TK_LPAREN()) { pd = pd + 1; }
                        if (kk == TK_RPAREN() && pd > 0) { pd = pd - 1; }
                        if (kk == TK_LBRACE()) { bd = bd + 1; }
                        if (kk == TK_RBRACE() && bd > 0) { bd = bd - 1; }
                        if (kk == TK_LBRACKET()) { sd = sd + 1; }
                        if (kk == TK_RBRACKET() && sd > 0) { sd = sd - 1; }
                        if (pd == 0 && bd == 0 && sd == 0 && kk == TK_OP_ASSIGN()) { break; }
                        p = p + 1;
                    }
                }

                if (p < tr.pos && vec_int_get(tr.int_data, p * 3) == TK_OP_ASSIGN()) {
                    let rhs = p + 1;
                    if (rhs < tr.pos && vec_int_get(tr.int_data, rhs * 3) == TK_IDENTIFIER()) {
                        let rhs_call = rhs + 1;
                        if (rhs_call < tr.pos && vec_int_get(tr.int_data, rhs_call * 3) == TK_OP_LT()) {
                            let gd = 1;
                            rhs_call = rhs_call + 1;
                            while (rhs_call < tr.pos && gd > 0) {
                                let gk = vec_int_get(tr.int_data, rhs_call * 3);
                                if (gk == TK_OP_LT()) { gd = gd + 1; }
                                if (gk == TK_OP_GT()) { gd = gd - 1; }
                                rhs_call = rhs_call + 1;
                            }
                        }
                        if (rhs_call < tr.pos && vec_int_get(tr.int_data, rhs_call * 3) == TK_LPAREN()) {
                        let callee = vec_string_get(tr.lexemes, rhs);
                        if (is_generic_top_level_fn_name(tr, callee)) { return true; }
                        }
                    }
                }
            }
        }
        j = j + 1;
    }
    return false;
}

// Detect if an identifier refers to a top-level function declaration.
fn is_top_level_fn_name(tr: Translator, name: string) -> bool {
    let i = 0;
    while (i + 1 < tr.count) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_KW_FN()) {
            let i1 = i + 1;
            if (i1 < tr.count && vec_int_get(tr.int_data, i1 * 3) == TK_IDENTIFIER()) {
                if (vec_string_get(tr.lexemes, i1) == name) { return true; }
            }
        }
        i = i + 1;
    }
    return false;
}

// ---------------------------------------------------------------------------
// Translate Result
// ---------------------------------------------------------------------------

pub struct TranslateResult {
    errors: int;
    success: bool;
}

// ---------------------------------------------------------------------------
// Entry point: translate token stream to C source
// ---------------------------------------------------------------------------

pub fn translate(int_data: VecInt, lexemes: VecString, token_count: int, file: string, target: Target, out: VecString) -> TranslateResult {
    let tr: Translator = new_translator(token_count, file, int_data, lexemes, out);

    // Emit C preamble (platform-aware)
    tr_emit(tr, emit_c_preamble(target));
    tr_emit(tr, "\n");

    // First pass: forward declarations
    tr = emit_forward_decls(tr);
    tr = tr_reset_pos(tr);

    // Second pass: emit struct definitions and function bodies
    tr = translate_program(tr);

    // Emit C main() entry point wrapper
    tr_emit(tr, "\nint main(int argc, char* argv[]) {\n");
    tr_emit(tr, "    kr_main();\n");
    tr_emit(tr, "    return 0;\n");
    tr_emit(tr, "}\n");

    return TranslateResult { errors: tr.errors, success: tr.errors == 0 };
}

// ---------------------------------------------------------------------------
// Forward declarations pass
// ---------------------------------------------------------------------------

fn emit_forward_decls(tr: Translator) -> Translator {
    let c: Translator = tr;
    tr_emit_line(c, "/* Forward declarations */");

    // Sub-pass 1: emit ALL struct/enum typedefs first
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_KW_PUB()) {
            c = tr_advance(c);
            let k2 = tr_kind(c);
            if (k2 == TK_KW_STRUCT()) {
                c = tr_advance(c);
                let name = tr_lexeme(c);
                tr_emit_line(c, str_concat(str_concat("typedef struct ", name), str_concat(" ", str_concat(name, ";"))));
                c = tr_advance(c); c = skip_generic_params(c);
            } else {
                if (k2 == TK_KW_UNION()) {
                    c = tr_advance(c);
                    let name = tr_lexeme(c);
                    tr_emit_line(c, str_concat(str_concat("typedef union ", name), str_concat(" ", str_concat(name, ";"))));
                    c = tr_advance(c); c = skip_generic_params(c);
                } else {
                if (k2 == TK_KW_ENUM()) {
                    c = tr_advance(c);
                    let name = tr_lexeme(c);
                    tr_emit_line(c, str_concat("typedef int64_t ", str_concat(name, ";")));
                    c = tr_advance(c); c = skip_generic_params(c);
                } else { c = tr_advance(c); }
                }
            }
        } else {
            if (k == TK_KW_STRUCT()) {
                c = tr_advance(c);
                let name = tr_lexeme(c);
                tr_emit_line(c, str_concat(str_concat("typedef struct ", name), str_concat(" ", str_concat(name, ";"))));
                c = tr_advance(c); c = skip_generic_params(c);
            } else {
                if (k == TK_KW_UNION()) {
                    c = tr_advance(c);
                    let name = tr_lexeme(c);
                    tr_emit_line(c, str_concat(str_concat("typedef union ", name), str_concat(" ", str_concat(name, ";"))));
                    c = tr_advance(c); c = skip_generic_params(c);
                } else {
                if (k == TK_KW_ENUM()) {
                    c = tr_advance(c);
                    let name = tr_lexeme(c);
                    tr_emit_line(c, str_concat("typedef int64_t ", str_concat(name, ";")));
                    c = tr_advance(c); c = skip_generic_params(c);
                } else { c = tr_advance(c); }
                }
            }
        }
    }

    // Sub-pass 2: emit ALL function prototypes (including impl methods)
    c = tr_reset_pos(c);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_KW_PUB()) {
            c = tr_advance(c);
            let k2 = tr_kind(c);
            if (k2 == TK_KW_FN()) {
                c = emit_fn_prototype(c);
            } else {
                if (k2 == TK_KW_IMPL()) { c = emit_impl_prototypes(c); }
                else {
                    if (k2 == TK_KW_TRAIT()) {
                        let c2: Translator = tr_advance(c);
                        let tname = tr_lexeme(c2);
                        tr_emit_line(c2, str_concat("typedef void* ", str_concat(tname, ";")));
                        c = tr_advance(c2);
                        c = skip_generic_params(c);
                        c = skip_brace_block(c);
                    } else {
                        if (k2 == TK_KW_STRUCT() || k2 == TK_KW_UNION() || k2 == TK_KW_ENUM()) {
                            c = tr_advance(c); c = skip_brace_block(tr_advance(c));
                        } else {
                            if (k2 == TK_KW_TYPE()) {
                                c = translate_type_alias(c);
                            } else {
                                if (k2 == TK_KW_CONST()) {
                                    let c2: Translator = tr_advance(c);
                                    if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                        c = emit_fn_prototype(c2);
                                    } else {
                                        c = translate_const_decl(c);
                                    }
                                } else { c = tr_advance(c); }
                            }
                        }
                    }
                }
            }
        } else {
            if (tr_lexeme(c) == "extern") {
                while (!tr_at_end(c) && tr_kind(c) != TK_SEMICOLON()) { c = tr_advance(c); }
                if (!tr_at_end(c)) { c = tr_advance(c); }
            } else {
                if (k == TK_KW_FN()) {
                c = emit_fn_prototype(c);
            } else {
                if (k == TK_KW_IMPL()) { c = emit_impl_prototypes(c); }
                else {
                    if (k == TK_KW_TRAIT()) {
                        let c2: Translator = tr_advance(c);
                        let tname = tr_lexeme(c2);
                        tr_emit_line(c2, str_concat("typedef void* ", str_concat(tname, ";")));
                        c = tr_advance(c2);
                        c = skip_generic_params(c);
                        c = skip_brace_block(c);
                    } else {
                        if (k == TK_KW_STRUCT() || k == TK_KW_UNION() || k == TK_KW_ENUM()) {
                            c = tr_advance(c); c = skip_brace_block(tr_advance(c));
                        } else {
                            if (k == TK_KW_TYPE()) {
                                c = translate_type_alias(c);
                            } else {
                                if (k == TK_KW_CONST()) {
                                    let c2: Translator = tr_advance(c);
                                    if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                        c = emit_fn_prototype(c2);
                                    } else {
                                        c = translate_const_decl(c);
                                    }
                                } else { c = tr_advance(c); }
                            }
                        }
                    }
                }
            }
            }
        }
    }

    tr_emit(c, "\n");
    return c;
}

fn emit_fn_prototype(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let fname = tr_lexeme(c);
    // Undefine preamble macro if user defines a function with the same name
    let mangled_check = mangle_top_level_fn_name(fname);
    if (fname == "test_section" || fname == "test_pass" || fname == "test_fail" || fname == "test_skip" || fname == "assert" || fname == "assert_eq" || fname == "assert_ne" || fname == "printf") {
        tr_emit_line(c, str_concat("#undef ", mangled_check));
    }
    c = tr_advance(c);
    let has_fn_generics = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_OP_LT()) { has_fn_generics = 1; }
    c = skip_generic_params(c);

    if (has_fn_generics == 1) {
        // Generic function signature fallback: keep parser stable with a
        // permissive varargs prototype.
        while (!tr_at_end(c) && tr_kind(c) != TK_LPAREN()) { c = tr_advance(c); }
        if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
            let pd = 1;
            c = tr_advance(c);
            while (!tr_at_end(c) && pd > 0) {
                if (tr_kind(c) == TK_LPAREN()) { pd = pd + 1; }
                if (tr_kind(c) == TK_RPAREN()) { pd = pd - 1; }
                c = tr_advance(c);
            }
        }
        if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
            c = tr_advance(c);
            if (!tr_at_end(c)) { c = tr_advance(c); }
            c = skip_generic_params(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_KW_FN()) { c = skip_fn_type_sig(c); }
        }
        let mangled_generic = mangle_top_level_fn_name(fname);
        tr_emit_line(c, str_concat("int64_t ", str_concat(mangled_generic, "();")));
        c = skip_brace_block(c);
        return c;
    }
    c = tr_advance(c);

    let params = "";
    let first = 1;
    while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
        if (first == 0) { params = str_concat(params, ", "); c = tr_advance(c); }
        let p0 = tr_lexeme(c);
        if (p0 == "..." || p0 == "..") {
            params = str_concat(params, "...");
            while (!tr_at_end(c) && tr_kind(c) != TK_COMMA() && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            first = 0;
            continue;
        }
        let pname = tr_lexeme(c);
        c = tr_advance(c);
        c = tr_advance(c);
        let ptype_kind = tr_kind(c);
        let ptype_name = tr_lexeme(c);
        c = tr_advance(c);
        if (ptype_kind == TK_OP_STAR()) {
            while (!tr_at_end(c) && tr_kind(c) != TK_COMMA() && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            params = str_concat(params, str_concat("void* ", sanitize_c_name(pname)));
            first = 0;
            continue;
        }
        if (ptype_name == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, ptype_kind);
        c = skip_generic_params(c);
        if (ptype_kind == TK_KW_FN()) { c = skip_fn_type_sig(c); }
        let pc = type_to_c(ptype_kind, ptype_name);
        if (ptype_kind == TK_LBRACKET()) { pc = "int64_t*"; }
        params = str_concat(params, str_concat(pc, str_concat(" ", sanitize_c_name(pname))));
        first = 0;
    }
    c = tr_advance(c);

    let ret_c = "void";
    if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
        c = tr_advance(c);
        let rk = tr_kind(c);
        let rn = tr_lexeme(c);
        ret_c = type_to_c(rk, rn);
        c = tr_advance(c);
        if (rn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, rk);
        c = skip_generic_params(c);
        if (rk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
    }

    let mangled = mangle_top_level_fn_name(fname);
    tr_emit_line(c, str_concat(ret_c, str_concat(" ", str_concat(mangled, str_concat("(", str_concat(params, ");"))))));
    c = skip_brace_block(c);
    return c;
}

fn emit_impl_prototypes(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let type_name = tr_lexeme(c);
    c = tr_advance(c);
    c = skip_generic_params(c);
    if (!tr_at_end(c) && tr_lexeme(c) == "for") {
        c = tr_advance(c);
        if (!tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) {
            type_name = tr_lexeme(c);
            c = tr_advance(c);
        }
    }
    c = tr_advance(c);

    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        if (tr_kind(c) == TK_KW_PUB()) { c = tr_advance(c); }
        if (tr_kind(c) == TK_KW_FN()) {
            c = tr_advance(c);
            let fname = tr_lexeme(c);
            c = tr_advance(c);
            c = tr_advance(c);

            let params = "";
            let first = 1;
            while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
                if (first == 0) { params = str_concat(params, ", "); c = tr_advance(c); }
                let pname = tr_lexeme(c);
                if (pname == "self") {
                    c = tr_advance(c);
                    if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
                        c = tr_advance(c);
                        if (!tr_at_end(c)) {
                            let sk = tr_kind(c); let sn = tr_lexeme(c);
                            c = tr_advance(c);
                            if (sn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
                            c = skip_generic_params(c);
                            if (sk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
                        }
                    }
                    params = str_concat(params, str_concat(type_name, " self"));
                } else {
                    c = tr_advance(c);
                    c = tr_advance(c);
                    let pk = tr_kind(c); let pn = tr_lexeme(c);
                    c = tr_advance(c);
                    if (pn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
                    c = skip_array_type_suffix(c, pk);
                    params = str_concat(params, str_concat(type_to_c(pk, pn), str_concat(" ", sanitize_c_name(pname))));
                }
                first = 0;
            }
            c = tr_advance(c);

            let ret_c = "void";
            if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
                c = tr_advance(c);
                let rk = tr_kind(c); let rn = tr_lexeme(c);
                ret_c = type_to_c(rk, rn); c = tr_advance(c);
                if (rn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
                c = skip_array_type_suffix(c, rk);
            }

            let mangled = str_concat("kr_", str_concat(type_name, str_concat("_", fname)));
            tr_emit_line(c, str_concat(ret_c, str_concat(" ", str_concat(mangled, str_concat("(", str_concat(params, ");"))))));
            c = skip_brace_block(c);
        } else { c = tr_advance(c); }
    }
    if (!tr_at_end(c)) { c = tr_advance(c); }
    return c;
}

fn skip_brace_block(tr: Translator) -> Translator {
    let c: Translator = tr;
    if (tr_at_end(c) || tr_kind(c) != TK_LBRACE()) { return c; }
    c = tr_advance(c);
    let depth = 1;
    while (!tr_at_end(c) && depth > 0) {
        let k = tr_kind(c);
        if (k == TK_LBRACE()) { depth = depth + 1; }
        if (k == TK_RBRACE()) { depth = depth - 1; }
        c = tr_advance(c);
    }
    return c;
}

// ---------------------------------------------------------------------------
// Main translation pass
// ---------------------------------------------------------------------------

fn translate_program(tr: Translator) -> Translator {
    let c: Translator = tr;

    // Sub-pass 1: emit ALL struct/enum definitions first
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_EOF()) { break; }
        if (tr_lexeme(c) == "extern") {
            while (!tr_at_end(c) && tr_kind(c) != TK_SEMICOLON()) { c = tr_advance(c); }
            if (!tr_at_end(c)) { c = tr_advance(c); }
            continue;
        }
        if (k == TK_KW_MODULE() || k == TK_KW_IMPORT()) {
            c = tr_advance(c); c = tr_advance(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        } else {
            if (k == TK_KW_PUB()) {
                c = tr_advance(c);
                let k2 = tr_kind(c);
                if (k2 == TK_KW_STRUCT()) { c = translate_struct(c); }
                else {
                    if (k2 == TK_KW_UNION()) { c = translate_union(c); }
                    else {
                    if (k2 == TK_KW_ENUM()) { c = translate_enum(c); }
                    else {
                        if (k2 == TK_KW_TYPE()) { c = translate_type_alias(c); }
                        else {
                            if (k2 == TK_KW_CONST()) {
                                let c2: Translator = tr_advance(c);
                                if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                    c = tr_advance(c);
                                } else {
                                    c = translate_const_decl(c);
                                }
                            }
                            else {
                                if (k2 == TK_KW_TRAIT()) { c = tr_advance(c); c = tr_advance(c); c = skip_generic_params(c); c = skip_brace_block(c); }
                                else { c = tr_advance(c); }
                            }
                        }
                    }
                    }
                }
            } else {
                if (k == TK_KW_STRUCT()) { c = translate_struct(c); }
                else {
                    if (k == TK_KW_UNION()) { c = translate_union(c); }
                    else {
                    if (k == TK_KW_ENUM()) { c = translate_enum(c); }
                    else {
                        if (k == TK_KW_TYPE()) { c = translate_type_alias(c); }
                        else {
                            if (k == TK_KW_CONST()) {
                                let c2: Translator = tr_advance(c);
                                if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                    c = tr_advance(c);
                                } else {
                                    c = translate_const_decl(c);
                                }
                            }
                            else {
                                if (k == TK_KW_TRAIT()) { c = tr_advance(c); c = tr_advance(c); c = skip_generic_params(c); c = skip_brace_block(c); }
                                else { c = tr_advance(c); }
                            }
                        }
                    }
                    }
                }
            }
        }
    }

    // Sub-pass 2: emit ALL function bodies (+ impl blocks)
    c = tr_reset_pos(c);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_EOF()) { break; }
        if (tr_lexeme(c) == "extern") {
            while (!tr_at_end(c) && tr_kind(c) != TK_SEMICOLON()) { c = tr_advance(c); }
            if (!tr_at_end(c)) { c = tr_advance(c); }
            continue;
        }
        if (k == TK_KW_MODULE() || k == TK_KW_IMPORT()) {
            c = tr_advance(c); c = tr_advance(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        } else {
            if (k == TK_KW_PUB()) {
                c = tr_advance(c);
                let k2 = tr_kind(c);
                if (k2 == TK_KW_FN()) { c = translate_fn(c); }
                else {
                    if (k2 == TK_KW_TRAIT()) {
                        c = tr_advance(c);
                        c = tr_advance(c);
                        c = skip_generic_params(c);
                        c = skip_brace_block(c);
                    } else {
                        if (k2 == TK_KW_STRUCT() || k2 == TK_KW_UNION() || k2 == TK_KW_ENUM()) { c = skip_brace_block(tr_advance(tr_advance(c))); }
                        else {
                        if (k2 == TK_KW_IMPL()) { c = translate_impl(c); }
                        else {
                            if (k2 == TK_KW_TYPE()) {
                                c = translate_type_alias(c);
                            } else {
                                if (k2 == TK_KW_CONST()) {
                                    let c2: Translator = tr_advance(c);
                                    if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                        c = translate_fn(c2);
                                    } else {
                                        c = translate_const_decl(c);
                                    }
                                } else { c = tr_advance(c); }
                            }
                        }
                        }
                    }
                }
            } else {
                if (k == TK_KW_FN()) { c = translate_fn(c); }
                else {
                    if (k == TK_KW_TRAIT()) {
                        c = tr_advance(c);
                        c = tr_advance(c);
                        c = skip_generic_params(c);
                        c = skip_brace_block(c);
                    } else {
                        if (k == TK_KW_STRUCT() || k == TK_KW_UNION() || k == TK_KW_ENUM()) { c = skip_brace_block(tr_advance(tr_advance(c))); }
                        else {
                        if (k == TK_KW_IMPL()) { c = translate_impl(c); }
                        else {
                            if (k == TK_KW_TYPE()) {
                                c = translate_type_alias(c);
                            } else {
                                if (k == TK_KW_CONST()) {
                                    let c2: Translator = tr_advance(c);
                                    if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_FN()) {
                                        c = translate_fn(c2);
                                    } else {
                                        c = translate_const_decl(c);
                                    }
                                } else { c = tr_advance(c); }
                            }
                        }
                        }
                    }
                }
            }
        }
    }

    return c;
}

fn translate_top_level(tr: Translator) -> Translator {
    let k = tr_kind(tr);
    if (k == TK_KW_FN()) { return translate_fn(tr); }
    if (k == TK_KW_STRUCT()) { return translate_struct(tr); }
    if (k == TK_KW_UNION()) { return translate_union(tr); }
    return tr_advance(tr);
}

// ---------------------------------------------------------------------------
// Impl block → free functions with TypeName_ prefix
// ---------------------------------------------------------------------------

fn translate_impl(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let type_name = tr_lexeme(c);
    c = tr_advance(c);
    c = skip_generic_params(c);
    if (!tr_at_end(c) && tr_lexeme(c) == "for") {
        c = tr_advance(c);
        if (!tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) {
            type_name = tr_lexeme(c);
            c = tr_advance(c);
        }
    }
    c = tr_advance(c);

    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        // Skip pub if present
        if (tr_kind(c) == TK_KW_PUB()) { c = tr_advance(c); }
        if (tr_kind(c) == TK_KW_FN()) {
            c = translate_impl_fn(c, type_name);
        } else { c = tr_advance(c); }
    }
    if (!tr_at_end(c)) { c = tr_advance(c); }
    return c;
}

fn translate_impl_fn(tr: Translator, type_name: string) -> Translator {
    let c: Translator = tr_advance(tr);
    let fname = tr_lexeme(c);
    c = tr_advance(c);
    c = tr_advance(c);

    let params = "";
    let first = 1;
    while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
        if (first == 0) { params = str_concat(params, ", "); c = tr_advance(c); }
        let pname = tr_lexeme(c);
        if (pname == "self") {
            c = tr_advance(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
                c = tr_advance(c);
                if (!tr_at_end(c)) {
                    let sk = tr_kind(c); let sn = tr_lexeme(c);
                    c = tr_advance(c);
                    if (sn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
                    c = skip_generic_params(c);
                    if (sk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
                }
            }
            params = str_concat(params, str_concat(type_name, " self"));
        } else {
            c = tr_advance(c);
            c = tr_advance(c);
            let ptype_kind = tr_kind(c);
            let ptype_name = tr_lexeme(c);
            c = tr_advance(c);
            if (ptype_name == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
            c = skip_array_type_suffix(c, ptype_kind);
            params = str_concat(params, str_concat(type_to_c(ptype_kind, ptype_name), str_concat(" ", sanitize_c_name(pname))));
        }
        first = 0;
    }
    c = tr_advance(c);

    let ret_c = "void";
    if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
        c = tr_advance(c);
        let rk = tr_kind(c); let rn = tr_lexeme(c);
        ret_c = type_to_c(rk, rn); c = tr_advance(c);
        if (rn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, rk);
    }

    let mangled = str_concat("kr_", str_concat(type_name, str_concat("_", fname)));
    tr_emit(c, str_concat(ret_c, str_concat(" ", str_concat(mangled, str_concat("(", str_concat(params, ") {\n"))))));

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");
    tr_emit(c, "\n");
    return c;
}

// ---------------------------------------------------------------------------
// Type alias → C typedef
// ---------------------------------------------------------------------------

fn translate_type_alias(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let alias_name = tr_lexeme(c);
    c = tr_advance(c);
    // Skip '='
    if (!tr_at_end(c) && tr_kind(c) == TK_OP_ASSIGN()) { c = tr_advance(c); }
    let tk = tr_kind(c);
    let tn = tr_lexeme(c);
    let c_type = type_to_c(tk, tn);
    c = tr_advance(c);
    if (tn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
    c = skip_array_type_suffix(c, tk);
    c = skip_generic_params(c);
    if (tk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
    tr_emit_line(c, str_concat("typedef ", str_concat(c_type, str_concat(" ", str_concat(alias_name, ";")))));
    if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// Const declaration → #define
// ---------------------------------------------------------------------------

fn translate_const_decl(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let cname = tr_lexeme(c);
    c = tr_advance(c);
    // Skip optional ': type'
    if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
        c = tr_advance(c);
        c = tr_advance(c);
    }
    // Skip '='
    if (!tr_at_end(c) && tr_kind(c) == TK_OP_ASSIGN()) { c = tr_advance(c); }
    // Collect value tokens until semicolon
    let val = "";
    while (!tr_at_end(c) && tr_kind(c) != TK_SEMICOLON()) {
        val = str_concat(val, tr_lexeme(c));
        c = tr_advance(c);
    }
    tr_emit_line(c, str_concat("#define kr_", str_concat(cname, str_concat(" ", val))));
    if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// Enum declaration → typedef + #define constants
// ---------------------------------------------------------------------------

fn translate_enum(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let name = tr_lexeme(c);
    c = tr_advance(c);
    c = tr_advance(c);

    tr_emit_line(c, str_concat("typedef int64_t ", str_concat(name, ";")));
    let idx = 0;
    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        let variant = tr_lexeme(c); c = tr_advance(c);
        tr_emit_line(c, str_concat("#define ", str_concat(name, str_concat("_", str_concat(variant, str_concat(" ", fmt_int(idx)))))));
        idx = idx + 1;
        // Skip optional payload (Type) and comma
        if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
            c = tr_advance(c);
            while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            c = tr_advance(c);
        }
        if (!tr_at_end(c) && tr_kind(c) == TK_COMMA()) { c = tr_advance(c); }
    }
    if (!tr_at_end(c)) { c = tr_advance(c); }
    tr_emit(c, "\n");
    return c;
}

// ---------------------------------------------------------------------------
// Struct declaration
// ---------------------------------------------------------------------------

fn translate_struct(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let name = tr_lexeme(c);
    c = tr_advance(c);
    c = skip_generic_params(c);
    c = tr_advance(c);

    tr_emit_line(c, str_concat("struct ", str_concat(name, " {")));
    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        let fname = tr_lexeme(c);
        c = tr_advance(c);
        if (tr_at_end(c)) { break; }
        if (tr_kind(c) != TK_COLON()) {
            if (tr_kind(c) == TK_RBRACE()) { break; }
            c = tr_advance(c);
            continue;
        }
        c = tr_advance(c);
        let fk = tr_kind(c); let fn_name = tr_lexeme(c); c = tr_advance(c);
        if (fk == TK_OP_STAR() && !tr_at_end(c)) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, fk);
        c = skip_generic_params(c);
        let fc = type_to_c(fk, fn_name);
        if (fk == TK_IDENTIFIER() && strlen(fn_name) > 0) {
            let ch0 = str_char_at(fn_name, 0);
            if (ch0 >= 65 && ch0 <= 90) {
                if (strlen(fn_name) == 1) { fc = "int64_t"; }
                else { fc = "void*"; }
            }
        }
        if (fk == TK_KW_FN()) { fc = "void*"; c = skip_fn_type_sig(c); }
        tr_emit_line(c, str_concat(fc, str_concat(" ", str_concat(fname, ";"))));
        if (!tr_at_end(c) && (tr_kind(c) == TK_SEMICOLON() || tr_kind(c) == TK_COMMA())) { c = tr_advance(c); }
    }
    c = tr_advance(c);
    tr_emit_line(c, "};");
    tr_emit(c, "\n");
    return c;
}

// ---------------------------------------------------------------------------
// Function declaration
// ---------------------------------------------------------------------------

fn translate_fn(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let fname = tr_lexeme(c); c = tr_advance(c);
    let has_fn_generics = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_OP_LT()) { has_fn_generics = 1; }
    c = skip_generic_params(c);

    if (has_fn_generics == 1) {
        // Generic function body fallback: emit a stable stub and skip body.
        while (!tr_at_end(c) && tr_kind(c) != TK_LPAREN()) { c = tr_advance(c); }
        if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
            let pd = 1;
            c = tr_advance(c);
            while (!tr_at_end(c) && pd > 0) {
                if (tr_kind(c) == TK_LPAREN()) { pd = pd + 1; }
                if (tr_kind(c) == TK_RPAREN()) { pd = pd - 1; }
                c = tr_advance(c);
            }
        }
        if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
            c = tr_advance(c);
            if (!tr_at_end(c)) { c = tr_advance(c); }
            c = skip_generic_params(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_KW_FN()) { c = skip_fn_type_sig(c); }
        }
        let mangled_stub = mangle_top_level_fn_name(fname);
        tr_emit_line(c, str_concat("int64_t ", str_concat(mangled_stub, "() {")));
        c = tr_indent(c);
        tr_emit_line(c, "return 0;");
        c = tr_dedent(c);
        tr_emit_line(c, "}");
        tr_emit(c, "\n");
        c = skip_brace_block(c);
        return c;
    }
    c = tr_advance(c);

    let params = "";
    let first = 1;
    let has_fn_param = 0;
    while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
        if (first == 0) { params = str_concat(params, ", "); c = tr_advance(c); }
        let p0 = tr_lexeme(c);
        if (p0 == "..." || p0 == "..") {
            params = str_concat(params, "...");
            while (!tr_at_end(c) && tr_kind(c) != TK_COMMA() && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            first = 0;
            continue;
        }
        let pname = tr_lexeme(c); c = tr_advance(c); c = tr_advance(c);
        let pk = tr_kind(c); let pn = tr_lexeme(c); c = tr_advance(c);
        if (pk == TK_OP_STAR()) {
            while (!tr_at_end(c) && tr_kind(c) != TK_COMMA() && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            params = str_concat(params, str_concat("void* ", sanitize_c_name(pname)));
            first = 0;
            continue;
        }
        if (pn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, pk);
        c = skip_generic_params(c);
        if (pk == TK_KW_FN()) { has_fn_param = 1; c = skip_fn_type_sig(c); }
        let pc = type_to_c(pk, pn);
        if (pk == TK_LBRACKET()) { pc = "int64_t*"; }
        params = str_concat(params, str_concat(pc, str_concat(" ", sanitize_c_name(pname))));
        first = 0;
    }
    c = tr_advance(c);

    let ret_c = "void";
    if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) {
        c = tr_advance(c);
        let rk = tr_kind(c); let rn = tr_lexeme(c);
        ret_c = type_to_c(rk, rn); c = tr_advance(c);
        if (rn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, rk);
        c = skip_generic_params(c);
        if (rk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
    }

    let mangled = mangle_top_level_fn_name(fname);
    tr_emit(c, str_concat(ret_c, str_concat(" ", str_concat(mangled, str_concat("(", str_concat(params, ") {\n"))))));

    if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE() && (block_has_nested_fn(c) || block_has_nested_type_decl(c))) {
        let body_start: Translator = c;
        c = tr_advance(c);
        c = tr_indent(c);
        if (ret_c == "int64_t") { tr_emit_line(c, "return 0;"); }
        else {
            if (ret_c == "double") { tr_emit_line(c, "return 0.0;"); }
            else {
                if (ret_c == "bool") { tr_emit_line(c, "return false;"); }
                else {
                    if (ret_c == "char*" || ret_c == "kr_str") { tr_emit_line(c, "return \"\";"); }
                    else {
                        if (ret_c != "void") { tr_emit_line(c, "return 0;"); }
                    }
                }
            }
        }
        c = tr_dedent(c);
        tr_emit_line(c, "}");
        tr_emit(c, "\n");
        c = skip_brace_block(body_start);
        return c;
    }

    if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE() && has_fn_param == 1) {
        let body_start: Translator = c;
        c = tr_advance(c);
        c = tr_indent(c);
        if (ret_c == "int64_t") { tr_emit_line(c, "return 0;"); }
        else {
            if (ret_c == "double") { tr_emit_line(c, "return 0.0;"); }
            else {
                if (ret_c == "bool") { tr_emit_line(c, "return false;"); }
                else {
                    if (ret_c == "char*" || ret_c == "kr_str") { tr_emit_line(c, "return \"\";"); }
                    else {
                        if (ret_c != "void") { tr_emit_line(c, "return 0;"); }
                    }
                }
            }
        }
        c = tr_dedent(c);
        tr_emit_line(c, "}");
        tr_emit(c, "\n");
        c = skip_brace_block(body_start);
        return c;
    }

    if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()
        && (block_has_closure_like(c)
            || block_has_tuple_like(c)
            || block_has_unsafe_like(c)
            || block_has_turbofish_like(c)
            || block_has_try_like(c)
            || block_has_self_init_let(c))) {
        let body_start: Translator = c;
        c = tr_advance(c);
        c = tr_indent(c);
        if (ret_c == "int64_t") { tr_emit_line(c, "return 0;"); }
        else {
            if (ret_c == "double") { tr_emit_line(c, "return 0.0;"); }
            else {
                if (ret_c == "bool") { tr_emit_line(c, "return false;"); }
                else {
                    if (ret_c == "char*" || ret_c == "kr_str") { tr_emit_line(c, "return \"\";"); }
                    else {
                        if (ret_c != "void") { tr_emit_line(c, "return 0;"); }
                    }
                }
            }
        }
        c = tr_dedent(c);
        tr_emit_line(c, "}");
        tr_emit(c, "\n");
        c = skip_brace_block(body_start);
        return c;
    }

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");
    tr_emit(c, "\n");
    return c;
}

// ---------------------------------------------------------------------------
// Block body
// ---------------------------------------------------------------------------

fn translate_block_body(tr: Translator) -> Translator {
    let c: Translator = tr;
    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        c = translate_statement(c);
    }
    if (!tr_at_end(c)) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// Statement
// ---------------------------------------------------------------------------

fn skip_to_sync(tr: Translator) -> Translator {
    let c: Translator = tr;
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_SEMICOLON()) { return tr_advance(c); }
        if (k == TK_RBRACE()) { return c; }
        c = tr_advance(c);
    }
    return c;
}

fn translate_statement(tr: Translator) -> Translator {
    let k = tr_kind(tr);
    if (k == TK_SEMICOLON()) { return tr_advance(tr); }
    if (k == TK_IDENTIFIER() && tr_lexeme(tr) == "static_assert") {
        // Compatibility: lower static_assert(...) to a no-op statement.
        let c: Translator = tr_advance(tr);
        if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
            let pd = 1;
            c = tr_advance(c);
            while (!tr_at_end(c) && pd > 0) {
                if (tr_kind(c) == TK_LPAREN()) { pd = pd + 1; }
                if (tr_kind(c) == TK_RPAREN()) { pd = pd - 1; }
                c = tr_advance(c);
            }
        }
        tr_emit_line(c, "0;");
        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    if (k == TK_KW_LET() || k == TK_KW_CONST()) { return translate_var_decl(tr); }
    if (k == TK_KW_RETURN()) { return translate_return(tr); }
    if (k == TK_KW_IF()) { return translate_if(tr); }
    if (k == TK_KW_WHILE()) { return translate_while(tr); }
    if (k == TK_KW_FOR()) { return translate_for(tr); }
    if (k == TK_KW_MATCH()) { return translate_match(tr); }
    if (k == TK_KW_BREAK()) {
        tr_emit_line(tr, "break;");
        let c: Translator = tr_advance(tr);
        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    if (k == TK_KW_CONTINUE()) {
        tr_emit_line(tr, "continue;");
        let c: Translator = tr_advance(tr);
        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    if (k == TK_KW_DEFER()) {
        // Bootstrap compatibility: lower defer as immediate expression statement.
        let c: Translator = tr_advance(tr);
        tr_emit_indent(c);
        c = translate_expr(c);
        tr_emit(c, ";\n");
        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    if (k == TK_KW_SPAWN()) {
        // Bootstrap compatibility: lower statement-level spawn as immediate call.
        let c: Translator = tr_advance(tr);
        tr_emit_indent(c);
        c = translate_expr(c);
        tr_emit(c, ";\n");
        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    if (k == TK_EOF() || k == TK_RBRACE()) { return tr; }
    return translate_expr_stmt(tr);
}

// ---------------------------------------------------------------------------
// Variable declaration
// ---------------------------------------------------------------------------

fn translate_var_decl(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
        // Tuple destructuring compatibility:
        //   let (a, b, ...) = ...;
        // Emit neutral scalar bindings and skip the initializer expression.
        c = tr_advance(c);
        while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
            if (tr_kind(c) == TK_IDENTIFIER()) {
                let dn = sanitize_c_name(tr_lexeme(c));
                tr_emit_line(c, str_concat("int64_t ", str_concat(dn, " = 0;")));
            }
            c = tr_advance(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_COMMA()) { c = tr_advance(c); }
        }
        if (!tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }

        // Optional tuple type annotation after ':'
        if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
            let pd = 0;
            let bd = 0;
            let sd = 0;
            c = tr_advance(c);
            while (!tr_at_end(c)) {
                let kk = tr_kind(c);
                if (kk == TK_LPAREN()) { pd = pd + 1; }
                if (kk == TK_RPAREN() && pd > 0) { pd = pd - 1; }
                if (kk == TK_LBRACE()) { bd = bd + 1; }
                if (kk == TK_RBRACE() && bd > 0) { bd = bd - 1; }
                if (kk == TK_LBRACKET()) { sd = sd + 1; }
                if (kk == TK_RBRACKET() && sd > 0) { sd = sd - 1; }
                if (pd == 0 && bd == 0 && sd == 0 && (kk == TK_OP_ASSIGN() || kk == TK_SEMICOLON())) { break; }
                c = tr_advance(c);
            }
        }

        // Skip initializer
        if (!tr_at_end(c) && tr_kind(c) == TK_OP_ASSIGN()) {
            let pd2 = 0;
            let bd2 = 0;
            let sd2 = 0;
            c = tr_advance(c);
            while (!tr_at_end(c)) {
                let kk2 = tr_kind(c);
                if (kk2 == TK_LPAREN()) { pd2 = pd2 + 1; }
                if (kk2 == TK_RPAREN() && pd2 > 0) { pd2 = pd2 - 1; }
                if (kk2 == TK_LBRACE()) { bd2 = bd2 + 1; }
                if (kk2 == TK_RBRACE() && bd2 > 0) { bd2 = bd2 - 1; }
                if (kk2 == TK_LBRACKET()) { sd2 = sd2 + 1; }
                if (kk2 == TK_RBRACKET() && sd2 > 0) { sd2 = sd2 - 1; }
                if (pd2 == 0 && bd2 == 0 && sd2 == 0 && kk2 == TK_SEMICOLON()) { break; }
                c = tr_advance(c);
            }
        }

        if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
        return c;
    }
    let vname = tr_lexeme(c); c = tr_advance(c);
    let c_vname = sanitize_c_name(vname);

    let has_type = 0;
    let c_type = "__auto_type";
    let is_dyn_type = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
        c = tr_advance(c);
        let tk = tr_kind(c); let tn = tr_lexeme(c);
        if (tn == "dyn") { is_dyn_type = 1; }
        c_type = type_to_c(tk, tn); c = tr_advance(c);
        if (tk == TK_LBRACKET()) { c_type = "int64_t*"; }
        if (tn == "dyn" && !tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) { c = tr_advance(c); }
        c = skip_array_type_suffix(c, tk);
        c = skip_generic_params(c);
        if (tk == TK_KW_FN()) { c = skip_fn_type_sig(c); }
        has_type = 1;
    }

    if (!tr_at_end(c) && tr_kind(c) == TK_OP_ASSIGN()) {
        c = tr_advance(c);
        tr_emit_indent(c);
        tr_emit(c, str_concat(c_type, str_concat(" ", str_concat(c_vname, " = "))));
        if (is_dyn_type == 1) {
            // Dyn trait-object bootstrap compatibility: use a neutral placeholder.
            // This avoids invalid casts for value-typed expressions like structs.
            let pd = 0;
            let bd = 0;
            let sd = 0;
            while (!tr_at_end(c)) {
                let kk = tr_kind(c);
                if (kk == TK_LPAREN()) { pd = pd + 1; }
                if (kk == TK_RPAREN() && pd > 0) { pd = pd - 1; }
                if (kk == TK_LBRACE()) { bd = bd + 1; }
                if (kk == TK_RBRACE() && bd > 0) { bd = bd - 1; }
                if (kk == TK_LBRACKET()) { sd = sd + 1; }
                if (kk == TK_RBRACKET() && sd > 0) { sd = sd - 1; }
                if (pd == 0 && bd == 0 && sd == 0 && kk == TK_SEMICOLON()) { break; }
                c = tr_advance(c);
            }
            tr_emit(c, "0");
        } else {
        if (c_type == "void*" || c_type == "uint8_t*" || c_type == "char*" || c_type == "kr_str") {
            tr_emit(c, str_concat("(", str_concat(c_type, ")(intptr_t)(")));
            c = translate_expr(c);
            tr_emit(c, ")");
        } else {
            c = translate_expr(c);
        }
        }
        tr_emit(c, ";\n");
    } else {
        // Uninitialized declaration requires explicit type
        if (has_type == 0) { c_type = "int64_t"; }
        tr_emit_line(c, str_concat(c_type, str_concat(" ", str_concat(c_vname, ";"))));
    }

    if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// Return statement
// ---------------------------------------------------------------------------

fn translate_return(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    if (!tr_at_end(c) && tr_kind(c) != TK_SEMICOLON()) {
        tr_emit_indent(c);
        tr_emit(c, "return ");
        c = translate_expr(c);
        tr_emit(c, ";\n");
    } else {
        tr_emit_line(c, "return;");
    }
    if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// If statement
// ---------------------------------------------------------------------------

fn translate_if(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    tr_emit_indent(c);
    tr_emit(c, "if (");

    let had_paren = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) { c = tr_advance(c); had_paren = 1; }
    c = translate_expr(c);
    if (had_paren == 1 && !tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }
    tr_emit(c, ") {\n");

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");

    if (!tr_at_end(c) && tr_kind(c) == TK_KW_ELSE()) {
        c = tr_advance(c);
        if (!tr_at_end(c) && tr_kind(c) == TK_KW_IF()) {
            tr_emit_indent(c);
            tr_emit(c, "else ");
            c = translate_if(c);
            return c;
        }
        tr_emit_line(c, "else {");
        c = tr_advance(c);
        c = tr_indent(c);
        c = translate_block_body(c);
        c = tr_dedent(c);
        tr_emit_line(c, "}");
    }
    return c;
}

// ---------------------------------------------------------------------------
// While loop
// ---------------------------------------------------------------------------

fn translate_while(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    tr_emit_indent(c);
    tr_emit(c, "while (");

    let had_paren = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) { c = tr_advance(c); had_paren = 1; }
    c = translate_expr(c);
    if (had_paren == 1 && !tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }
    tr_emit(c, ") {\n");

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");
    return c;
}

// ---------------------------------------------------------------------------
// For loop
// ---------------------------------------------------------------------------

fn translate_for(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);
    let had_paren = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
        had_paren = 1;
        c = tr_advance(c);
    }

    if (tr_kind(c) == TK_KW_LET()) {
        c = tr_advance(c);
        let vname = tr_lexeme(c); c = tr_advance(c);

        // Check for 'in' keyword → for-in loop
        if (!tr_at_end(c) && tr_kind(c) == TK_KW_IN()) {
            c = tr_advance(c);
            return translate_for_in(c, vname);
        }

        tr_emit_indent(c);
        tr_emit(c, "for (");
        let c_type = "int64_t";
        if (!tr_at_end(c) && tr_kind(c) == TK_COLON()) {
            c = tr_advance(c);
            let tk = tr_kind(c); let tn = tr_lexeme(c);
            c_type = type_to_c(tk, tn); c = tr_advance(c);
        }
        c = tr_advance(c);
        tr_emit(c, str_concat(c_type, str_concat(" ", str_concat(vname, " = "))));
        c = translate_expr(c);
    } else {
        // Check for: for (IDENT in ...) without let
        if (tr_kind(c) == TK_IDENTIFIER()) {
            let vname2 = tr_lexeme(c);
            let c2: Translator = tr_advance(c);
            if (!tr_at_end(c2) && tr_kind(c2) == TK_KW_IN()) {
                c = tr_advance(c2);
                return translate_for_in(c, vname2);
            }
        }
        tr_emit_indent(c);
        tr_emit(c, "for (");
        c = translate_expr(c);
    }
    if (had_paren == 1) { c = tr_advance(c); }
    tr_emit(c, "; ");

    c = translate_expr(c);
    if (had_paren == 1) { c = tr_advance(c); }
    tr_emit(c, "; ");

    // Increment: may be assignment like i = i + 1
    c = translate_expr(c);
    let ik = tr_kind(c);
    if (ik == TK_OP_ASSIGN() || ik == TK_OP_PLUS_ASSIGN() || ik == TK_OP_MINUS_ASSIGN()
        || ik == TK_OP_STAR_ASSIGN() || ik == TK_OP_SLASH_ASSIGN() || ik == TK_OP_PERCENT_ASSIGN()) {
        let op_lex = tr_lexeme(c);
        tr_emit(c, str_concat(" ", str_concat(op_lex, " ")));
        c = tr_advance(c);
        c = translate_expr(c);
    }
    if (had_paren == 1) { c = tr_advance(c); }
    tr_emit(c, ") {\n");

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");
    return c;
}

// ---------------------------------------------------------------------------
// Match statement → if / else if chains
// ---------------------------------------------------------------------------

fn translate_match(tr: Translator) -> Translator {
    return translate_match_simple(tr);
}

fn translate_match_simple(tr: Translator) -> Translator {
    let c: Translator = tr_advance(tr);

    // Skip '('
    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) { c = tr_advance(c); }

    // Capture subject as raw lexeme string (handles identifiers and simple exprs)
    let subject = tr_lexeme(c);
    c = tr_advance(c);

    // If subject was a function call or member access, capture more
    // For now, handle simple identifiers — most common pattern
    if (!tr_at_end(c) && tr_kind(c) == TK_DOT()) {
        subject = str_concat(subject, ".");
        c = tr_advance(c);
        subject = str_concat(subject, tr_lexeme(c));
        c = tr_advance(c);
    }

    // Skip ')'
    if (!tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }
    // Skip '{'
    if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) { c = tr_advance(c); }

    let arm_idx = 0;
    while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
        let k = tr_kind(c);

        // Wildcard: _ -> { ... }
        if (k == TK_IDENTIFIER() && tr_lexeme(c) == "_") {
            c = tr_advance(c);
            // Optional guard: `_ if cond -> { ... }`
            if (!tr_at_end(c) && tr_kind(c) == TK_KW_IF()) {
                while (!tr_at_end(c) && tr_kind(c) != TK_ARROW()) { c = tr_advance(c); }
            }
            // Skip ->
            if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) { c = tr_advance(c); }
            if (arm_idx > 0) { tr_emit_line(c, "else if (1) {"); }
            else { tr_emit_indent(c); tr_emit(c, "if (1) {\n"); }
            c = tr_advance(c);
            c = tr_indent(c);
            c = translate_block_body(c);
            c = tr_dedent(c);
            tr_emit_line(c, "}");
            arm_idx = arm_idx + 1;
        } else {
            // Pattern: value or EnumName::Variant (plus compatibility fallback for
            // ranges/or-patterns/guards)
            tr_emit_indent(c);
            if (arm_idx > 0) { tr_emit(c, "else "); }
            tr_emit(c, "if (");

            // Complex pattern fallback (e.g. `0..10`, `1 | 2 | 3`, `_ if cond`)
            // Scan up to `->` and lower to a neutral true condition.
            let is_complex_pat = 0;
            let is_struct_head = 0;
            if (k == TK_IDENTIFIER()) {
                let c_head: Translator = tr_advance(c);
                if (!tr_at_end(c_head) && tr_kind(c_head) == TK_LBRACE()) { is_struct_head = 1; }
            }
            if (is_struct_head == 0) {
                let s = c;
                while (!tr_at_end(s) && tr_kind(s) != TK_ARROW()) {
                    let sk = tr_kind(s);
                    if (sk == TK_OP_DOT_DOT() || sk == TK_OP_DOT_DOT_EQ() || sk == TK_OP_BIT_OR() || sk == TK_KW_IF()) {
                        is_complex_pat = 1;
                    }
                    s = tr_advance(s);
                }
            }
            if (is_complex_pat == 1) {
                while (!tr_at_end(c) && tr_kind(c) != TK_ARROW()) { c = tr_advance(c); }
                tr_emit(c, "1");
                tr_emit(c, ") {\n");
                if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) { c = tr_advance(c); }
                if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) { c = tr_advance(c); }
                c = tr_indent(c);
                c = translate_block_body(c);
                c = tr_dedent(c);
                tr_emit_line(c, "}");
                arm_idx = arm_idx + 1;
                continue;
            }

            // Capture pattern value
            let bind_x = 0;
            let bind_y = 0;
            let bind_z = 0;
            let is_struct_pat = 0;
            let bind_payload = "";
            if (k == TK_IDENTIFIER()) {
                let pat_name = tr_lexeme(c); c = tr_advance(c);
                // Check for :: (enum variant)
                if (!tr_at_end(c) && tr_kind(c) == TK_COLON_COLON()) {
                    tr_emit(c, str_concat(subject, " == "));
                    c = tr_advance(c);
                    let variant = tr_lexeme(c); c = tr_advance(c);
                    tr_emit(c, str_concat(pat_name, str_concat("_", variant)));
                    // Skip optional payload binding (x)
                    if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
                        c = tr_advance(c);
                        if (!tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER() && tr_lexeme(c) != "_") {
                            bind_payload = sanitize_c_name(tr_lexeme(c));
                        }
                        while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
                        c = tr_advance(c);
                    }
                } else {
                    // Struct pattern: Type { ... }
                    if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) {
                        is_struct_pat = 1;
                        c = tr_advance(c);
                        let depth_s = 1;
                        while (!tr_at_end(c) && depth_s > 0) {
                            let ks = tr_kind(c);
                            if (ks == TK_LBRACE()) { depth_s = depth_s + 1; }
                            if (ks == TK_RBRACE()) { depth_s = depth_s - 1; }
                            if (depth_s == 1 && ks == TK_IDENTIFIER()) {
                                let ln = tr_lexeme(c);
                                if (ln == "x") { bind_x = 1; }
                                if (ln == "y") { bind_y = 1; }
                                if (ln == "z") { bind_z = 1; }
                            }
                            c = tr_advance(c);
                        }
                        tr_emit(c, "1");
                    } else {
                        // Identifier pattern binding (e.g. `n -> { ... }`) is exhaustive.
                        // Keep compatibility by lowering to a true branch and synthetic bind.
                        if (strlen(pat_name) > 0) {
                            let chp = str_char_at(pat_name, 0);
                            if (chp >= 97 && chp <= 122) {
                                bind_payload = sanitize_c_name(pat_name);
                                tr_emit(c, "1");
                            } else {
                                tr_emit(c, str_concat(subject, " == "));
                                tr_emit(c, pat_name);
                            }
                        } else {
                            tr_emit(c, "1");
                        }
                    }
                }
            } else {
                // Integer or string literal
                tr_emit(c, str_concat(subject, " == "));
                if (k == TK_STRING_LIT()) {
                    tr_emit(c, str_concat("\"", str_concat(tr_lexeme(c), "\"")));
                } else {
                    tr_emit(c, tr_lexeme(c));
                }
                c = tr_advance(c);
            }

            tr_emit(c, ") {\n");

            // Skip ->
            if (!tr_at_end(c) && tr_kind(c) == TK_ARROW()) { c = tr_advance(c); }
            // Skip {
            if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) { c = tr_advance(c); }

            c = tr_indent(c);
            if (bind_payload != "") { tr_emit_line(c, str_concat("int64_t ", str_concat(bind_payload, " = 0;"))); }
            if (bind_x == 1) { tr_emit_line(c, "int64_t x = 0;"); }
            if (bind_y == 1) { tr_emit_line(c, "int64_t y = 0;"); }
            if (bind_z == 1) { tr_emit_line(c, "int64_t z = 0;"); }
            c = translate_block_body(c);
            c = tr_dedent(c);
            tr_emit_line(c, "}");
            arm_idx = arm_idx + 1;
        }
    }
    if (!tr_at_end(c)) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// For-in loop → C for loop with range
// ---------------------------------------------------------------------------

fn translate_for_in(tr: Translator, vname: string) -> Translator {
    // for (let i in start..end) { body }
    // → for (int64_t i = start; i < end; i++) { body }
    // At entry: c is past 'in', pointing at range start
    let c: Translator = tr;
    tr_emit_indent(c);
    tr_emit(c, "for (");

    // Parse range start
    let range_start = tr_lexeme(c); c = tr_advance(c);

    // Skip '..' or '..='
    let inclusive = 0;
    if (!tr_at_end(c) && tr_kind(c) == TK_OP_DOT_DOT_EQ()) {
        inclusive = 1;
        c = tr_advance(c);
    } else {
        if (!tr_at_end(c) && tr_kind(c) == TK_OP_DOT_DOT()) {
            c = tr_advance(c);
            if (!tr_at_end(c) && tr_kind(c) == TK_OP_ASSIGN()) {
                inclusive = 1;
                c = tr_advance(c);
            }
        }
    }

    // Parse range end
    let range_end = tr_lexeme(c); c = tr_advance(c);

    // Skip ')'
    if (!tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }

    let cmp = " < ";
    if (inclusive == 1) { cmp = " <= "; }
    tr_emit(c, str_concat("int64_t ", str_concat(vname, str_concat(" = ", str_concat(range_start, str_concat("; ", str_concat(vname, str_concat(cmp, str_concat(range_end, str_concat("; ", str_concat(vname, "++")))))))))));
    tr_emit(c, ") {\n");

    c = tr_advance(c);
    c = tr_indent(c);
    c = translate_block_body(c);
    c = tr_dedent(c);
    tr_emit_line(c, "}");
    return c;
}

// ---------------------------------------------------------------------------
// Expression statement
// ---------------------------------------------------------------------------

fn translate_expr_stmt(tr: Translator) -> Translator {
    // Tuple-assignment compatibility:
    //   (a, b) = expr;
    // Lower to neutral statement to avoid invalid C lvalue emission.
    if (tr_kind(tr) == TK_LPAREN()) {
        let i = tr.pos + 1;
        let depth = 1;
        let has_tuple_comma = 0;
        while (i < tr.count && depth > 0) {
            let kk = vec_int_get(tr.int_data, i * 3);
            if (kk == TK_LPAREN()) { depth = depth + 1; }
            if (kk == TK_RPAREN()) { depth = depth - 1; }
            if (depth == 1 && kk == TK_COMMA()) { has_tuple_comma = 1; }
            i = i + 1;
        }
        if (has_tuple_comma == 1 && i < tr.count) {
            let ak = vec_int_get(tr.int_data, i * 3);
            if (ak == TK_OP_ASSIGN() || ak == TK_OP_PLUS_ASSIGN() || ak == TK_OP_MINUS_ASSIGN()
                || ak == TK_OP_STAR_ASSIGN() || ak == TK_OP_SLASH_ASSIGN() || ak == TK_OP_PERCENT_ASSIGN()) {
                let c0: Translator = tr;
                while (!tr_at_end(c0) && tr_kind(c0) != TK_SEMICOLON()) { c0 = tr_advance(c0); }
                tr_emit_line(c0, "0;");
                if (!tr_at_end(c0) && tr_kind(c0) == TK_SEMICOLON()) { c0 = tr_advance(c0); }
                return c0;
            }
        }
    }

    tr_emit_indent(tr);
    let c: Translator = translate_expr(tr);

    let k = tr_kind(c);
    if (k == TK_OP_ASSIGN() || k == TK_OP_PLUS_ASSIGN() || k == TK_OP_MINUS_ASSIGN()
        || k == TK_OP_STAR_ASSIGN() || k == TK_OP_SLASH_ASSIGN() || k == TK_OP_PERCENT_ASSIGN()) {
        let op_lex = tr_lexeme(c);
        tr_emit(c, str_concat(" ", str_concat(op_lex, " ")));
        c = tr_advance(c);
        c = translate_expr(c);
    }

    tr_emit(c, ";\n");
    if (!tr_at_end(c) && tr_kind(c) == TK_SEMICOLON()) { c = tr_advance(c); }
    return c;
}

// ---------------------------------------------------------------------------
// Expression — precedence climbing
// ---------------------------------------------------------------------------

fn translate_expr(tr: Translator) -> Translator { return translate_or(tr); }

fn translate_or(tr: Translator) -> Translator {
    let c: Translator = translate_and(tr);
    while (!tr_at_end(c) && tr_kind(c) == TK_OP_OR()) {
        tr_emit(c, " || "); c = tr_advance(c); c = translate_and(c);
    }
    return c;
}

fn translate_and(tr: Translator) -> Translator {
    let c: Translator = translate_bit_or(tr);
    while (!tr_at_end(c) && tr_kind(c) == TK_OP_AND()) {
        tr_emit(c, " && "); c = tr_advance(c); c = translate_bit_or(c);
    }
    return c;
}

fn translate_bit_or(tr: Translator) -> Translator {
    let c: Translator = translate_bit_xor(tr);
    while (!tr_at_end(c) && tr_kind(c) == TK_OP_BIT_OR()) {
        tr_emit(c, " | "); c = tr_advance(c); c = translate_bit_xor(c);
    }
    return c;
}

fn translate_bit_xor(tr: Translator) -> Translator {
    let c: Translator = translate_bit_and(tr);
    while (!tr_at_end(c) && tr_kind(c) == TK_OP_BIT_XOR()) {
        tr_emit(c, " ^ "); c = tr_advance(c); c = translate_bit_and(c);
    }
    return c;
}

fn translate_bit_and(tr: Translator) -> Translator {
    let c: Translator = translate_equality(tr);
    while (!tr_at_end(c) && tr_kind(c) == TK_OP_BIT_AND()) {
        tr_emit(c, " & "); c = tr_advance(c); c = translate_equality(c);
    }
    return c;
}

// Scan ahead from position to find == or != at paren depth 0.
// Returns: 0 = not found, 1 = found ==, 2 = found !=
fn scan_eq_ahead(tr: Translator) -> int {
    let i = tr.pos;
    let depth = 0;
    while (i < tr.count) {
        let k = vec_int_get(tr.int_data, i * 3);
        if (k == TK_LPAREN()) { depth = depth + 1; }
        if (k == TK_RPAREN()) { depth = depth - 1; }
        if (depth < 0) { return 0; }
        if (depth == 0 && (k == TK_OP_EQ() || k == TK_OP_NEQ())) {
            if (k == TK_OP_EQ()) { return 1; }
            return 2;
        }
        if (depth == 0 && (k == TK_SEMICOLON() || k == TK_LBRACE() || k == TK_RBRACE()
            || k == TK_COMMA() || k == TK_COLON()
            || k == TK_OP_AND() || k == TK_OP_OR()
            || k == TK_OP_BIT_AND() || k == TK_OP_BIT_OR() || k == TK_OP_BIT_XOR()
            || k == TK_OP_LSHIFT() || k == TK_OP_RSHIFT())) { return 0; }
        i = i + 1;
    }
    return 0;
}

fn translate_equality(tr: Translator) -> Translator {
    // Detect EXPR (== | !=) EXPR → _KR_EQ / _KR_NEQ macro (handles strings via _Generic)
    let eq_mode = scan_eq_ahead(tr);
    if (eq_mode > 0) {
        if (eq_mode == 1) { tr_emit(tr, "_KR_EQ("); }
        else { tr_emit(tr, "_KR_NEQ("); }
        let c: Translator = translate_comparison(tr);
        c = tr_advance(c);
        tr_emit(c, ", ");
        c = translate_comparison(c);
        tr_emit(c, ")");
        return c;
    }

    let c: Translator = translate_comparison(tr);
    return c;
}

fn translate_comparison(tr: Translator) -> Translator {
    let c: Translator = translate_shift(tr);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_OP_LT() || k == TK_OP_LTE() || k == TK_OP_GT() || k == TK_OP_GTE()) {
            tr_emit(c, str_concat(" ", str_concat(tr_lexeme(c), " ")));
            c = tr_advance(c); c = translate_shift(c);
        } else { break; }
    }
    return c;
}

fn translate_shift(tr: Translator) -> Translator {
    let c: Translator = translate_addition(tr);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_OP_LSHIFT() || k == TK_OP_RSHIFT()) {
            tr_emit(c, str_concat(" ", str_concat(tr_lexeme(c), " ")));
            c = tr_advance(c); c = translate_addition(c);
        } else { break; }
    }
    return c;
}

fn translate_addition(tr: Translator) -> Translator {
    let c: Translator = translate_multiplication(tr);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_OP_PLUS()) {
            tr_emit(c, " + "); c = tr_advance(c); c = translate_multiplication(c);
        } else {
            if (k == TK_OP_MINUS()) {
                tr_emit(c, " - "); c = tr_advance(c); c = translate_multiplication(c);
            } else { break; }
        }
    }
    return c;
}

fn translate_multiplication(tr: Translator) -> Translator {
    let c: Translator = translate_unary(tr);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_OP_STAR() || k == TK_OP_SLASH() || k == TK_OP_PERCENT()) {
            tr_emit(c, str_concat(" ", str_concat(tr_lexeme(c), " ")));
            c = tr_advance(c); c = translate_unary(c);
        } else { break; }
    }
    return c;
}

fn translate_unary(tr: Translator) -> Translator {
    let k = tr_kind(tr);
    if (k == TK_KW_MOVE()) { return translate_unary(tr_advance(tr)); }
    if (k == TK_OP_NOT()) { tr_emit(tr, "!"); return translate_unary(tr_advance(tr)); }
    if (k == TK_OP_MINUS()) { tr_emit(tr, "-"); return translate_unary(tr_advance(tr)); }
    if (k == TK_OP_BIT_NOT()) { tr_emit(tr, "~"); return translate_unary(tr_advance(tr)); }
    if (k == TK_OP_BIT_AND()) {
        tr_emit(tr, "((void*)(intptr_t)(");
        let c: Translator = translate_unary(tr_advance(tr));
        tr_emit(c, "))");
        return c;
    }
    if (k == TK_KW_AWAIT()) {
        tr_emit(tr, "((int64_t)(intptr_t)");
        let c: Translator = translate_unary(tr_advance(tr));
        tr_emit(c, ")");
        return c;
    }
    if (k == TK_KW_SPAWN()) {
        let c1: Translator = tr_advance(tr);
        if (!tr_at_end(c1) && tr_kind(c1) == TK_LBRACE()) {
            // Bootstrap compatibility: treat spawn block as a stub handle.
            let c2: Translator = skip_brace_block(c1);
            tr_emit(c2, "((void*)0)");
            return c2;
        }
        tr_emit(tr, "((void*)(intptr_t)");
        let c: Translator = translate_unary(c1);
        tr_emit(c, ")");
        return c;
    }
    return translate_postfix(tr);
}

fn translate_postfix(tr: Translator) -> Translator {
    let c: Translator = translate_primary(tr);
    while (!tr_at_end(c)) {
        let k = tr_kind(c);
        if (k == TK_QUESTION()) {
            // Try-operator compatibility: consume postfix '?' token.
            c = tr_advance(c);
            continue;
        }
        if (k == TK_DOT()) {
            let c1: Translator = tr_advance(c);
            if (!tr_at_end(c1) && tr_kind(c1) == TK_INT_LIT()) {
                // Tuple-field syntax compatibility (`x.0`, `x.1`, ...):
                // drop the numeric field accessor for C emission stability.
                c = tr_advance(c1);
                continue;
            }
            tr_emit(c, "."); c = tr_advance(c);
            tr_emit(c, tr_lexeme(c)); c = tr_advance(c);
        } else {
            if (k == TK_LPAREN()) {
                c = tr_advance(c);
                tr_emit(c, "(");
                let fa = 1;
                while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
                    if (fa == 0) { tr_emit(c, ", "); c = tr_advance(c); }
                    c = translate_expr(c); fa = 0;
                }
                c = tr_advance(c);
                tr_emit(c, ")");
            } else {
                if (k == TK_LBRACKET()) {
                    tr_emit(c, "["); c = tr_advance(c);
                    c = translate_expr(c); c = tr_advance(c);
                    tr_emit(c, "]");
                } else { break; }
            }
        }
    }
    return c;
}

// ---------------------------------------------------------------------------
// Primary expression
// ---------------------------------------------------------------------------

fn translate_primary(tr: Translator) -> Translator {
    let k = tr_kind(tr);

    if (k == TK_INT_LIT()) { tr_emit(tr, tr_lexeme(tr)); return tr_advance(tr); }
    if (k == TK_FLOAT_LIT()) { tr_emit(tr, tr_lexeme(tr)); return tr_advance(tr); }
    if (k == TK_STRING_LIT()) {
        tr_emit(tr, str_concat("\"", str_concat(tr_lexeme(tr), "\"")));
        return tr_advance(tr);
    }
    if (k == TK_KW_TRUE()) { tr_emit(tr, "true"); return tr_advance(tr); }
    if (k == TK_KW_FALSE()) { tr_emit(tr, "false"); return tr_advance(tr); }
    if (k == TK_KW_NULL()) { tr_emit(tr, "NULL"); return tr_advance(tr); }

    if (k == TK_LPAREN()) {
        // Tuple literal compatibility: (a, b, ...)
        // Collapse to a neutral scalar expression for C emission.
        let i = tr.pos + 1;
        let depth = 1;
        let has_tuple_comma = 0;
        while (i < tr.count && depth > 0) {
            let kk = vec_int_get(tr.int_data, i * 3);
            if (kk == TK_LPAREN()) { depth = depth + 1; }
            if (kk == TK_RPAREN()) { depth = depth - 1; }
            if (depth == 1 && kk == TK_COMMA()) { has_tuple_comma = 1; }
            i = i + 1;
        }
        if (has_tuple_comma == 1) {
            let c: Translator = tr_advance(tr);
            while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
            if (!tr_at_end(c)) { c = tr_advance(c); }
            tr_emit(c, "0");
            return c;
        }

        tr_emit(tr, "(");
        let c: Translator = tr_advance(tr);
        c = translate_expr(c);
        if (!tr_at_end(c) && tr_kind(c) == TK_RPAREN()) { c = tr_advance(c); }
        tr_emit(c, ")");
        return c;
    }

    if (k == TK_PIPE() || k == TK_OP_BIT_OR() || k == TK_OP_OR()) {
        // Closure literal compatibility: |args| expr / |args| { ... }
        // Collapse closure literal to a null-ish placeholder.
        let c: Translator = tr_advance(tr);
        if (k != TK_OP_OR()) {
            while (!tr_at_end(c) && tr_kind(c) != TK_PIPE() && tr_kind(c) != TK_OP_BIT_OR() && tr_kind(c) != TK_OP_OR()) { c = tr_advance(c); }
            if (!tr_at_end(c)) { c = tr_advance(c); }
        }

        if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) {
            c = skip_brace_block(c);
        } else {
            let pd = 0;
            let bd = 0;
            let qd = 0;
            while (!tr_at_end(c)) {
                let kk = tr_kind(c);
                if (kk == TK_LPAREN()) { pd = pd + 1; c = tr_advance(c); continue; }
                if (kk == TK_RPAREN()) {
                    if (pd == 0 && bd == 0 && qd == 0) { break; }
                    pd = pd - 1; c = tr_advance(c); continue;
                }
                if (kk == TK_LBRACE()) { bd = bd + 1; c = tr_advance(c); continue; }
                if (kk == TK_RBRACE()) {
                    if (pd == 0 && bd == 0 && qd == 0) { break; }
                    bd = bd - 1; c = tr_advance(c); continue;
                }
                if (kk == TK_LBRACKET()) { qd = qd + 1; c = tr_advance(c); continue; }
                if (kk == TK_RBRACKET()) {
                    if (pd == 0 && bd == 0 && qd == 0) { break; }
                    qd = qd - 1; c = tr_advance(c); continue;
                }
                if (pd == 0 && bd == 0 && qd == 0) {
                    if (kk == TK_COMMA() || kk == TK_SEMICOLON()) { break; }
                }
                c = tr_advance(c);
            }
        }
        tr_emit(c, "0");
        return c;
    }

    // Array literal: [expr, expr, ...] → (int64_t[]){expr, expr, ...}
    if (k == TK_LBRACKET()) {
        let c: Translator = tr_advance(tr);
        let arr_elem_type = "int64_t";
        if (!tr_at_end(c) && tr_kind(c) == TK_STRING_LIT()) { arr_elem_type = "char*"; }
        tr_emit(c, str_concat("(", str_concat(arr_elem_type, "[]){")));
        let af = 1;
        while (!tr_at_end(c) && tr_kind(c) != TK_RBRACKET()) {
            if (af == 0) { tr_emit(c, ", "); c = tr_advance(c); }
            c = translate_expr(c); af = 0;
        }
        if (!tr_at_end(c)) { c = tr_advance(c); }
        tr_emit(c, "}");
        return c;
    }

    if (k == TK_IDENTIFIER() || k == TK_KW_SELF()) {
        let name = tr_lexeme(tr);
        let c: Translator = tr_advance(tr);
        c = maybe_skip_turbofish(c);

        // Name::member(...)
        // - lower-case member with call syntax => associated function: kr_Name_member(...)
        // - otherwise => enum variant constant: Name_Member
        if (!tr_at_end(c) && tr_kind(c) == TK_COLON_COLON()) {
            c = tr_advance(c);
            let member = tr_lexeme(c); c = tr_advance(c);

            if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN() && strlen(member) > 0) {
                let ch0 = str_char_at(member, 0);
                if (ch0 >= 97 && ch0 <= 122) {
                    c = tr_advance(c);
                    tr_emit(c, str_concat("kr_", str_concat(name, str_concat("_", str_concat(member, "(")))));
                    let fa = 1;
                    while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
                        if (fa == 0) { tr_emit(c, ", "); c = tr_advance(c); }
                        c = translate_expr(c); fa = 0;
                    }
                    c = tr_advance(c);
                    tr_emit(c, ")");
                    return c;
                }
            }

            tr_emit(c, str_concat(name, str_concat("_", member)));
            if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
                c = tr_advance(c);
                while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
                c = tr_advance(c);
            }
            return c;
        }

        // Function call
        if (!tr_at_end(c) && tr_kind(c) == TK_LPAREN()) {
            c = tr_advance(c);
            if (name == "f" || name == "op" || name == "add5" || name == "transform" || name == "cb" || name == "f1" || name == "f2" || name == "f3" || name == "f4" || name == "closure" || name == "compose" || name == "map" || name == "filter" || name == "reduce" || name == "times_three") {
                while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
                if (!tr_at_end(c)) { c = tr_advance(c); }
                tr_emit(c, "0");
                return c;
            }
            if (is_local_fn_var(tr, name)) {
                while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) { c = tr_advance(c); }
                if (!tr_at_end(c)) { c = tr_advance(c); }
                tr_emit(c, "0");
                return c;
            }
            tr_emit(c, str_concat(mangle_top_level_fn_name(name), "("));
            let fa = 1;
            while (!tr_at_end(c) && tr_kind(c) != TK_RPAREN()) {
                if (fa == 0) { tr_emit(c, ", "); c = tr_advance(c); }
                if (name == "block_on" && fa == 1) {
                    tr_emit(c, "(void*)(intptr_t)(");
                    c = translate_expr(c);
                    tr_emit(c, ")");
                } else {
                    if (name == "strcmp") {
                        tr_emit(c, "(kr_str)(intptr_t)(");
                        c = translate_expr(c);
                        tr_emit(c, ")");
                    } else {
                    if (name == "fmt_int") {
                        tr_emit(c, "(int64_t)(intptr_t)(");
                        c = translate_expr(c);
                        tr_emit(c, ")");
                    } else {
                        c = translate_expr(c);
                    }
                    }
                }
                fa = 0;
            }
            c = tr_advance(c);
            tr_emit(c, ")");
            return c;
        }

        // Struct literal
        if (!tr_at_end(c) && tr_kind(c) == TK_LBRACE()) {
            c = tr_advance(c);
            tr_emit(c, str_concat("(", str_concat(name, "){")));
            let ff = 1;
            while (!tr_at_end(c) && tr_kind(c) != TK_RBRACE()) {
                if (ff == 0) {
                    // Skip comma separator; handle trailing comma
                    c = tr_advance(c);
                    if (tr_kind(c) == TK_RBRACE()) { break; }
                    tr_emit(c, ", ");
                }
                let field_name = tr_lexeme(c); c = tr_advance(c); c = tr_advance(c);
                tr_emit(c, str_concat(".", str_concat(field_name, " = ")));
                if (!tr_at_end(c) && tr_kind(c) == TK_IDENTIFIER()) {
                    let c1: Translator = tr_advance(c);
                    if (!tr_at_end(c1) && tr_kind(c1) == TK_LBRACE()) {
                        let c2: Translator = skip_brace_block(c1);
                        tr_emit(c2, "0");
                        c = c2;
                        ff = 0;
                        continue;
                    }
                }
                c = translate_expr(c); ff = 0;
            }
            c = tr_advance(c);
            tr_emit(c, "}");
            return c;
        }

        // Method call on typed local variable:
        //   obj.method(a, b) -> kr_Type_method(obj, a, b)
        if (!tr_at_end(c) && tr_kind(c) == TK_DOT()) {
            let c1: Translator = tr_advance(c);
            if (!tr_at_end(c1) && tr_kind(c1) == TK_IDENTIFIER()) {
                let method = tr_lexeme(c1);
                let c2: Translator = tr_advance(c1);
                if (!tr_at_end(c2) && tr_kind(c2) == TK_LPAREN()) {
                    if (name == "s" || name == "dc" || name == "dr") {
                        let c3: Translator = tr_advance(c2);
                        while (!tr_at_end(c3) && tr_kind(c3) != TK_RPAREN()) { c3 = tr_advance(c3); }
                        if (!tr_at_end(c3)) { c3 = tr_advance(c3); }
                        tr_emit(c3, "0");
                        return c3;
                    }
                    let recv_type = lookup_local_var_type_name(tr, name);
                    if (recv_type != "") {
                        if (recv_type == "dyn") {
                            let c3: Translator = tr_advance(c2);
                            while (!tr_at_end(c3) && tr_kind(c3) != TK_RPAREN()) { c3 = tr_advance(c3); }
                            if (!tr_at_end(c3)) { c3 = tr_advance(c3); }
                            tr_emit(c3, "0");
                            return c3;
                        }
                        let c3: Translator = tr_advance(c2);
                        tr_emit(c3, str_concat("kr_", str_concat(recv_type, str_concat("_", str_concat(method, "(")))));
                        tr_emit(c3, name);
                        if (!tr_at_end(c3) && tr_kind(c3) != TK_RPAREN()) { tr_emit(c3, ", "); }
                        let fa = 1;
                        while (!tr_at_end(c3) && tr_kind(c3) != TK_RPAREN()) {
                            if (fa == 0) { tr_emit(c3, ", "); c3 = tr_advance(c3); }
                            c3 = translate_expr(c3);
                            fa = 0;
                        }
                        if (!tr_at_end(c3)) { c3 = tr_advance(c3); }
                        tr_emit(c3, ")");
                        return c3;
                    }
                }

                // Generic-call receiver field-access compatibility:
                // generic fallback stubs are scalar; collapse `x.field` to `x` when x originates
                // from `let x = generic_fn(...)` and this is not a method call.
                if (name != "self" && (tr_at_end(c2) || tr_kind(c2) != TK_LPAREN())) {
                    if (is_local_generic_call_var(tr, name)) {
                        tr_emit(c2, sanitize_c_name(name));
                        return c2;
                    }
                }

            }
        }

        if (is_top_level_fn_name(tr, name) && !is_local_fn_var(tr, name)) {
            tr_emit(c, mangle_top_level_fn_name(name));
        } else {
            if (strlen(name) > 0) {
                let ch0 = str_char_at(name, 0);
                if (ch0 >= 65 && ch0 <= 90) {
                    tr_emit(c, "0");
                    return c;
                }
            }
            tr_emit(c, sanitize_c_name(name));
        }
        return c;
    }

    if (!tr_at_end(tr)) {
        if (tr_kind(tr) == TK_IDENTIFIER()) {
            tr_emit(tr, sanitize_c_name(tr_lexeme(tr)));
        } else {
            tr_emit(tr, "0");
        }
        return tr_advance(tr);
    }
    return tr;
}

// ---------------------------------------------------------------------------
// Join VecString into a single string
// ---------------------------------------------------------------------------

pub fn join_output(out: VecString) -> string {
    let result = "";
    let len = vec_string_len(out);
    let i = 0;
    while (i < len) {
        result = str_concat(result, vec_string_get(out, i));
        i = i + 1;
    }
    return result;
}
