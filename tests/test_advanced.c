// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
void kr_fclose(void* f) { fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }

/* Forward declarations */
typedef struct Rect Rect;
int64_t kr_abs_val(int64_t x);
int64_t kr_max(int64_t a, int64_t b);
int64_t kr_min(int64_t a, int64_t b);
int64_t kr_clamp(int64_t x, int64_t lo, int64_t hi);
Rect kr_new_rect(int64_t x, int64_t y, int64_t w, int64_t h);
int64_t kr_rect_area(Rect r);
bool kr_rect_contains(Rect r, int64_t px, int64_t py);
int64_t kr_sum_vec(void* v);
int64_t kr_vec_max(void* v);
kr_str kr_repeat_char(kr_str ch, int64_t n);
kr_str kr_pad_right(kr_str s, int64_t width);
kr_str kr_classify_number(int64_t n);
int64_t kr_fib(int64_t n);
int64_t kr_gcd(int64_t a, int64_t b);
void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual);
void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual);
void kr_assert_true(kr_str label, bool value);
int64_t kr_main();

struct Rect {
int64_t x;
int64_t y;
int64_t w;
int64_t h;
};

int64_t kr_abs_val(int64_t x) {
    if (x < 0) {
        return -x;
    }
    return x;
}

int64_t kr_max(int64_t a, int64_t b) {
    if (a > b) {
        return a;
    }
    return b;
}

int64_t kr_min(int64_t a, int64_t b) {
    if (a < b) {
        return a;
    }
    return b;
}

int64_t kr_clamp(int64_t x, int64_t lo, int64_t hi) {
    return kr_max(lo, kr_min(x, hi));
}

Rect kr_new_rect(int64_t x, int64_t y, int64_t w, int64_t h) {
    return (Rect){.x = x, .y = y, .w = w, .h = h};
}

int64_t kr_rect_area(Rect r) {
    return r.w * r.h;
}

bool kr_rect_contains(Rect r, int64_t px, int64_t py) {
    return px >= r.x && px < r.x + r.w && py >= r.y && py < r.y + r.h;
}

int64_t kr_sum_vec(void* v) {
    __auto_type total = 0;
    __auto_type i = 0;
    __auto_type len = kr_vec_int_len(v);
    while (i < len) {
        total = total + kr_vec_int_get(v, i);
        i = i + 1;
    }
    return total;
}

int64_t kr_vec_max(void* v) {
    __auto_type best = kr_vec_int_get(v, 0);
    __auto_type i = 1;
    __auto_type len = kr_vec_int_len(v);
    while (i < len) {
        __auto_type val = kr_vec_int_get(v, i);
        if (val > best) {
            best = val;
        }
        i = i + 1;
    }
    return best;
}

kr_str kr_repeat_char(kr_str ch, int64_t n) {
    __auto_type result = "";
    __auto_type i = 0;
    while (i < n) {
        result = kr_str_concat(result, ch);
        i = i + 1;
    }
    return result;
}

kr_str kr_pad_right(kr_str s, int64_t width) {
    __auto_type len = kr_strlen(s);
    if (len >= width) {
        return s;
    }
    return kr_str_concat(s, kr_repeat_char(" ", width - len));
}

kr_str kr_classify_number(int64_t n) {
    if (n < 0) {
        if (n < -100) {
            return "very negative";
        }
        if (n < -10) {
            return "negative";
        }
        return "slightly negative";
    }
    else {
        if (_KR_EQ(n, 0)) {
            return "zero";
        }
        if (n <= 10) {
            return "small positive";
        }
        if (n <= 100) {
            return "positive";
        }
        return "very positive";
    }
    return "unreachable";
}

int64_t kr_fib(int64_t n) {
    if (n <= 1) {
        return n;
    }
    __auto_type a = 0;
    __auto_type b = 1;
    __auto_type i = 2;
    while (i <= n) {
        __auto_type tmp = a + b;
        a = b;
        b = tmp;
        i = i + 1;
    }
    return b;
}

int64_t kr_gcd(int64_t a, int64_t b) {
    __auto_type x = a;
    __auto_type y = b;
    while (_KR_NEQ(y, 0)) {
        __auto_type t = y;
        __auto_type m = x - (x / y) * y;
        x = y;
        y = m;
    }
    return x;
}

void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(kr_fmt_int(expected), kr_str_concat(" actual=", kr_fmt_int(actual)))))));
    }
}

void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(expected, kr_str_concat(" actual=", actual))))));
    }
}

void kr_assert_true(kr_str label, bool value) {
    if (value) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", label));
    }
}

int64_t kr_main() {
    kr_puts("=== krakenc Advanced Test Suite ===");
    kr_puts("");
    kr_puts("[Math]");
    kr_assert_eq_int("abs(-5)", 5, kr_abs_val(-5));
    kr_assert_eq_int("abs(3)", 3, kr_abs_val(3));
    kr_assert_eq_int("max(3,7)", 7, kr_max(3, 7));
    kr_assert_eq_int("min(3,7)", 3, kr_min(3, 7));
    kr_assert_eq_int("clamp(50,0,100)", 50, kr_clamp(50, 0, 100));
    kr_assert_eq_int("clamp(-5,0,100)", 0, kr_clamp(-5, 0, 100));
    kr_assert_eq_int("clamp(200,0,100)", 100, kr_clamp(200, 0, 100));
    kr_puts("[Rect]");
    __auto_type r = kr_new_rect(10, 20, 30, 40);
    kr_assert_eq_int("area", 1200, kr_rect_area(r));
    kr_assert_true("contains(15,25)", kr_rect_contains(r, 15, 25));
    kr_assert_true("!contains(5,25)", !kr_rect_contains(r, 5, 25));
    kr_assert_true("!contains(50,25)", !kr_rect_contains(r, 50, 25));
    kr_puts("[VecInt]");
    __auto_type v = kr_vec_int_new();
    kr_vec_int_push(v, 10);
    kr_vec_int_push(v, 20);
    kr_vec_int_push(v, 30);
    kr_vec_int_push(v, 5);
    kr_assert_eq_int("sum", 65, kr_sum_vec(v));
    kr_assert_eq_int("max", 30, kr_vec_max(v));
    kr_assert_eq_int("len", 4, kr_vec_int_len(v));
    kr_puts("[String Ops]");
    kr_assert_eq_str("repeat('x',3)", "xxx", kr_repeat_char("x", 3));
    kr_assert_eq_str("pad_right('hi',5)", "hi   ", kr_pad_right("hi", 5));
    kr_assert_eq_str("pad_right('hello',3)", "hello", kr_pad_right("hello", 3));
    kr_puts("[Classification]");
    kr_assert_eq_str("classify(-200)", "very negative", kr_classify_number(-200));
    kr_assert_eq_str("classify(-50)", "negative", kr_classify_number(-50));
    kr_assert_eq_str("classify(-3)", "slightly negative", kr_classify_number(-3));
    kr_assert_eq_str("classify(0)", "zero", kr_classify_number(0));
    kr_assert_eq_str("classify(5)", "small positive", kr_classify_number(5));
    kr_assert_eq_str("classify(50)", "positive", kr_classify_number(50));
    kr_assert_eq_str("classify(500)", "very positive", kr_classify_number(500));
    kr_puts("[Fibonacci]");
    kr_assert_eq_int("fib(0)", 0, kr_fib(0));
    kr_assert_eq_int("fib(1)", 1, kr_fib(1));
    kr_assert_eq_int("fib(10)", 55, kr_fib(10));
    kr_assert_eq_int("fib(20)", 6765, kr_fib(20));
    kr_puts("[GCD]");
    kr_assert_eq_int("gcd(12,8)", 4, kr_gcd(12, 8));
    kr_assert_eq_int("gcd(100,75)", 25, kr_gcd(100, 75));
    kr_assert_eq_int("gcd(7,13)", 1, kr_gcd(7, 13));
    kr_puts("");
    kr_puts("=== All advanced tests complete ===");
    return 0;
}


int main(int argc, char* argv[]) {
    return (int)kr_main();
}
