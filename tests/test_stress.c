// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
void kr_fclose(void* f) { fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }

/* Forward declarations */
typedef struct BigStruct BigStruct;
typedef int64_t Season;
void kr_assert_eq(kr_str label, int64_t expected, int64_t actual);
void kr_assert_str(kr_str label, kr_str expected, kr_str actual);
void kr_assert_true(kr_str label, bool v);
int64_t kr_deeply_nested(int64_t x);
int64_t kr_complex_expr(int64_t a, int64_t b, int64_t c);
kr_str kr_chained_calls(kr_str s);
kr_str kr_multi_return(int64_t x);
int64_t kr_sum_big(BigStruct s);
kr_str kr_season_name(int64_t s);
bool kr_is_warm(int64_t s);
int64_t kr_count_digits(int64_t n);
int64_t kr_reverse_int(int64_t n);
int64_t kr_sum_of_squares(int64_t n);
int64_t kr_factorial(int64_t n);
bool kr_complex_bool(int64_t a, int64_t b, int64_t c);
kr_str kr_join_strings(kr_str sep, int64_t count);
int64_t kr_main();

struct BigStruct {
int64_t a;
int64_t b;
int64_t c;
int64_t d;
int64_t e;
int64_t f;
};

typedef int64_t Season;
#define Season_Spring 0
#define Season_Summer 1
#define Season_Autumn 2
#define Season_Winter 3

void kr_assert_eq(kr_str label, int64_t expected, int64_t actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" exp=", kr_str_concat(kr_fmt_int(expected), kr_str_concat(" got=", kr_fmt_int(actual)))))));
    }
}

void kr_assert_str(kr_str label, kr_str expected, kr_str actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" exp=", kr_str_concat(expected, kr_str_concat(" got=", actual))))));
    }
}

void kr_assert_true(kr_str label, bool v) {
    if (v) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", label));
    }
}

int64_t kr_deeply_nested(int64_t x) {
    if (x > 0) {
        if (x > 10) {
            if (x > 100) {
                if (x > 1000) {
                    return 4;
                }
                else {
                    return 3;
                }
            }
            else {
                return 2;
            }
        }
        else {
            return 1;
        }
    }
    else {
        return 0;
    }
    return -1;
}

int64_t kr_complex_expr(int64_t a, int64_t b, int64_t c) {
    return (a + b) * c - (a * b) / (c + 1) + (a % (b + 1));
}

kr_str kr_chained_calls(kr_str s) {
    return kr_str_concat(kr_str_concat(kr_str_concat("[", s), "]"), kr_str_concat(" len=", kr_fmt_int(kr_strlen(s))));
}

kr_str kr_multi_return(int64_t x) {
    if (x < 0) {
        return "negative";
    }
    if (_KR_EQ(x, 0)) {
        return "zero";
    }
    if (_KR_EQ(x, 1)) {
        return "one";
    }
    if (_KR_EQ(x, 2)) {
        return "two";
    }
    if (x < 10) {
        return "small";
    }
    if (x < 100) {
        return "medium";
    }
    return "large";
}

int64_t kr_sum_big(BigStruct s) {
    return s.a + s.b + s.c + s.d + s.e + s.f;
}

kr_str kr_season_name(int64_t s) {
    if (s == Season_Spring) {
        return "spring";
    }
    else if (s == Season_Summer) {
        return "summer";
    }
    else if (s == Season_Autumn) {
        return "autumn";
    }
    else if (s == Season_Winter) {
        return "winter";
    }
    else {
        return "unknown";
    }
    return "";
}

bool kr_is_warm(int64_t s) {
    return _KR_EQ(s, Season_Spring) || _KR_EQ(s, Season_Summer);
}

int64_t kr_count_digits(int64_t n) {
    if (_KR_EQ(n, 0)) {
        return 1;
    }
    __auto_type val = n;
    if (val < 0) {
        val = -val;
    }
    __auto_type count = 0;
    while (val > 0) {
        val = val / 10;
        count = count + 1;
    }
    return count;
}

int64_t kr_reverse_int(int64_t n) {
    __auto_type val = n;
    __auto_type neg = 0;
    if (val < 0) {
        val = -val;
        neg = 1;
    }
    __auto_type result = 0;
    while (val > 0) {
        __auto_type m = val - (val / 10) * 10;
        result = result * 10 + m;
        val = val / 10;
    }
    if (_KR_EQ(neg, 1)) {
        return -result;
    }
    return result;
}

int64_t kr_sum_of_squares(int64_t n) {
    __auto_type total = 0;
    for (int64_t i = 0; i < n; i++) {
        total = total + i * i;
    }
    return total;
}

int64_t kr_factorial(int64_t n) {
    __auto_type result = 1;
    for (int64_t i = 1; i < n; i++) {
        result = result * i;
    }
    result = result * n;
    return result;
}

bool kr_complex_bool(int64_t a, int64_t b, int64_t c) {
    return (a > 0 && b > 0) || (c < 0 && _KR_NEQ(a, b)) || (_KR_EQ(a, 0) && _KR_EQ(b, 0) && _KR_EQ(c, 0));
}

kr_str kr_join_strings(kr_str sep, int64_t count) {
    __auto_type v = kr_vec_string_new();
    for (int64_t i = 0; i < count; i++) {
        kr_vec_string_push(v, kr_fmt_int(i));
    }
    __auto_type result = "";
    __auto_type i = 0;
    while (i < kr_vec_string_len(v)) {
        if (i > 0) {
            result = kr_str_concat(result, sep);
        }
        result = kr_str_concat(result, kr_vec_string_get(v, i));
        i = i + 1;
    }
    return result;
}

int64_t kr_main() {
    kr_puts("=== krakenc Stress Test ===");
    kr_puts("");
    kr_puts("[Deep Nesting]");
    kr_assert_eq("nest(0)", 0, kr_deeply_nested(0));
    kr_assert_eq("nest(5)", 1, kr_deeply_nested(5));
    kr_assert_eq("nest(50)", 2, kr_deeply_nested(50));
    kr_assert_eq("nest(500)", 3, kr_deeply_nested(500));
    kr_assert_eq("nest(5000)", 4, kr_deeply_nested(5000));
    kr_puts("[Complex Expr]");
    kr_assert_eq("complex(3,4,5)", 36, kr_complex_expr(3, 4, 5));
    kr_assert_str("chained(hi)", "[hi] len=2", kr_chained_calls("hi"));
    kr_puts("[Multi Return]");
    kr_assert_str("mr(-1)", "negative", kr_multi_return(-1));
    kr_assert_str("mr(0)", "zero", kr_multi_return(0));
    kr_assert_str("mr(1)", "one", kr_multi_return(1));
    kr_assert_str("mr(2)", "two", kr_multi_return(2));
    kr_assert_str("mr(7)", "small", kr_multi_return(7));
    kr_assert_str("mr(42)", "medium", kr_multi_return(42));
    kr_assert_str("mr(999)", "large", kr_multi_return(999));
    kr_puts("[BigStruct]");
    __auto_type bs = (BigStruct){.a = 1, .b = 2, .c = 3, .d = 4, .e = 5, .f = 6};
    kr_assert_eq("sum_big", 21, kr_sum_big(bs));
    kr_assert_eq("bs.d", 4, bs.d);
    kr_puts("[Enums + Match]");
    kr_assert_str("spring", "spring", kr_season_name(Season_Spring));
    kr_assert_str("winter", "winter", kr_season_name(Season_Winter));
    kr_assert_true("warm(spring)", kr_is_warm(Season_Spring));
    kr_assert_true("warm(summer)", kr_is_warm(Season_Summer));
    kr_assert_true("!warm(winter)", !kr_is_warm(Season_Winter));
    kr_puts("[Digit Count]");
    kr_assert_eq("digits(0)", 1, kr_count_digits(0));
    kr_assert_eq("digits(5)", 1, kr_count_digits(5));
    kr_assert_eq("digits(42)", 2, kr_count_digits(42));
    kr_assert_eq("digits(999)", 3, kr_count_digits(999));
    kr_assert_eq("digits(-42)", 2, kr_count_digits(-42));
    kr_puts("[Reverse Int]");
    kr_assert_eq("rev(123)", 321, kr_reverse_int(123));
    kr_assert_eq("rev(1000)", 1, kr_reverse_int(1000));
    kr_assert_eq("rev(-456)", -654, kr_reverse_int(-456));
    kr_puts("[Sum Squares]");
    kr_assert_eq("sq(0)", 0, kr_sum_of_squares(0));
    kr_assert_eq("sq(4)", 14, kr_sum_of_squares(4));
    kr_assert_eq("sq(5)", 30, kr_sum_of_squares(5));
    kr_puts("[Factorial]");
    kr_assert_eq("fact(1)", 1, kr_factorial(1));
    kr_assert_eq("fact(5)", 120, kr_factorial(5));
    kr_assert_eq("fact(10)", 3628800, kr_factorial(10));
    kr_puts("[Complex Bool]");
    kr_assert_true("cb(1,1,0)", kr_complex_bool(1, 1, 0));
    kr_assert_true("cb(0,0,0)", kr_complex_bool(0, 0, 0));
    kr_assert_true("cb(-1,0,-1)", kr_complex_bool(-1, 0, -1));
    kr_assert_true("!cb(-1,-1,1)", !kr_complex_bool(-1, -1, 1));
    kr_puts("[VecString Join]");
    kr_assert_str("join(3)", "0,1,2", kr_join_strings(",", 3));
    kr_assert_str("join(1)", "0", kr_join_strings(",", 1));
    kr_assert_str("join(5)", "0-1-2-3-4", kr_join_strings("-", 5));
    kr_puts("");
    kr_puts("=== All stress tests complete ===");
    return 0;
}


int main(int argc, char* argv[]) {
    return (int)kr_main();
}
