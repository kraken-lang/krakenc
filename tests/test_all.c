// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
void kr_fclose(void* f) { fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }

/* Forward declarations */
typedef struct Point Point;
typedef int64_t Direction;
Point kr_new_point(int64_t x, int64_t y);
int64_t kr_Point_dist_sq(Point self);
Point kr_Point_add(Point self, Point other);
kr_str kr_Point_to_string(Point self);
kr_str kr_dir_name(int64_t d);
kr_str kr_fizzbuzz(int64_t n);
int64_t kr_match_int(int64_t x);
int64_t kr_sum_range(int64_t start, int64_t end);
kr_str kr_repeat_str(kr_str s, int64_t n);
bool kr_has_flag(int64_t value, int64_t flag);
int64_t kr_set_flag(int64_t value, int64_t flag);
int64_t kr_toggle_flag(int64_t value, int64_t flag);
kr_str kr_classify_word(kr_str w);
int64_t kr_collatz_steps(int64_t n);
Point kr_trailing_comma_test();
void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual);
void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual);
void kr_assert_true(kr_str label, bool value);
int64_t kr_main();

struct Point {
int64_t x;
int64_t y;
};

typedef int64_t Direction;
#define Direction_North 0
#define Direction_South 1
#define Direction_East 2
#define Direction_West 3

Point kr_new_point(int64_t x, int64_t y) {
    return (Point){.x = x, .y = y};
}

int64_t kr_Point_dist_sq(Point self) {
    return self.x * self.x + self.y * self.y;
}

Point kr_Point_add(Point self, Point other) {
    return (Point){.x = self.x + other.x, .y = self.y + other.y};
}

kr_str kr_Point_to_string(Point self) {
    return kr_str_concat("(", kr_str_concat(kr_fmt_int(self.x), kr_str_concat(",", kr_str_concat(kr_fmt_int(self.y), ")"))));
}

kr_str kr_dir_name(int64_t d) {
    if (d == Direction_North) {
        return "north";
    }
    else if (d == Direction_South) {
        return "south";
    }
    else if (d == Direction_East) {
        return "east";
    }
    else if (d == Direction_West) {
        return "west";
    }
    else {
        return "unknown";
    }
    return "unreachable";
}

kr_str kr_fizzbuzz(int64_t n) {
    __auto_type m3 = n - (n / 3) * 3;
    __auto_type m5 = n - (n / 5) * 5;
    if (_KR_EQ(m3, 0) && _KR_EQ(m5, 0)) {
        return "fizzbuzz";
    }
    if (_KR_EQ(m3, 0)) {
        return "fizz";
    }
    if (_KR_EQ(m5, 0)) {
        return "buzz";
    }
    return kr_fmt_int(n);
}

int64_t kr_match_int(int64_t x) {
    if (x == 1) {
        return 10;
    }
    else if (x == 2) {
        return 20;
    }
    else if (x == 3) {
        return 30;
    }
    else {
        return 99;
    }
    return 0;
}

int64_t kr_sum_range(int64_t start, int64_t end) {
    __auto_type total = 0;
    for (int64_t i = start; i < end; i++) {
        total = total + i;
    }
    return total;
}

kr_str kr_repeat_str(kr_str s, int64_t n) {
    __auto_type result = "";
    __auto_type i = 0;
    while (i < n) {
        result = kr_str_concat(result, s);
        i = i + 1;
    }
    return result;
}

bool kr_has_flag(int64_t value, int64_t flag) {
    return _KR_NEQ((value & flag), 0);
}

int64_t kr_set_flag(int64_t value, int64_t flag) {
    return value | flag;
}

int64_t kr_toggle_flag(int64_t value, int64_t flag) {
    return value ^ flag;
}

kr_str kr_classify_word(kr_str w) {
    if (_KR_EQ(w, "hello")) {
        return "greeting";
    }
    if (_KR_EQ(w, "goodbye")) {
        return "farewell";
    }
    if (_KR_EQ(w, "")) {
        return "empty";
    }
    return "other";
}

int64_t kr_collatz_steps(int64_t n) {
    __auto_type steps = 0;
    __auto_type val = n;
    while (_KR_NEQ(val, 1)) {
        __auto_type m2 = val - (val / 2) * 2;
        if (_KR_EQ(m2, 0)) {
            val = val / 2;
        }
        else {
            val = val * 3 + 1;
        }
        steps = steps + 1;
    }
    return steps;
}

Point kr_trailing_comma_test() {
    return (Point){.x = 100, .y = 200};
}

void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(kr_fmt_int(expected), kr_str_concat(" actual=", kr_fmt_int(actual)))))));
    }
}

void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(expected, kr_str_concat(" actual=", actual))))));
    }
}

void kr_assert_true(kr_str label, bool value) {
    if (value) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", label));
    }
}

int64_t kr_main() {
    kr_puts("=== krakenc Translator Test Suite ===");
    kr_puts("");
    kr_puts("[Structs]");
    __auto_type p1 = kr_new_point(3, 4);
    kr_assert_eq_int("point.x", 3, p1.x);
    kr_assert_eq_int("point.y", 4, p1.y);
    kr_puts("[Impl]");
    kr_assert_eq_int("dist_sq(3,4)", 25, kr_Point_dist_sq(p1));
    __auto_type p2 = kr_new_point(1, 2);
    __auto_type p3 = kr_Point_add(p1, p2);
    kr_assert_eq_int("add.x", 4, p3.x);
    kr_assert_eq_int("add.y", 6, p3.y);
    kr_assert_eq_str("to_string", "(3,4)", kr_Point_to_string(p1));
    kr_puts("[Trailing Comma]");
    __auto_type tc = kr_trailing_comma_test();
    kr_assert_eq_int("trailing.x", 100, tc.x);
    kr_assert_eq_int("trailing.y", 200, tc.y);
    kr_puts("[Enums]");
    kr_assert_eq_str("dir north", "north", kr_dir_name(Direction_North));
    kr_assert_eq_str("dir south", "south", kr_dir_name(Direction_South));
    kr_assert_eq_str("dir east", "east", kr_dir_name(Direction_East));
    kr_assert_eq_str("dir west", "west", kr_dir_name(Direction_West));
    kr_puts("[Match]");
    kr_assert_eq_int("match(1)", 10, kr_match_int(1));
    kr_assert_eq_int("match(2)", 20, kr_match_int(2));
    kr_assert_eq_int("match(3)", 30, kr_match_int(3));
    kr_assert_eq_int("match(9)", 99, kr_match_int(9));
    kr_puts("[For-in]");
    kr_assert_eq_int("sum(0..5)", 10, kr_sum_range(0, 5));
    kr_assert_eq_int("sum(1..4)", 6, kr_sum_range(1, 4));
    kr_assert_eq_int("sum(0..1)", 0, kr_sum_range(0, 1));
    kr_puts("[While + String]");
    kr_assert_eq_str("repeat('ab',3)", "ababab", kr_repeat_str("ab", 3));
    kr_assert_eq_str("repeat('x',0)", "", kr_repeat_str("x", 0));
    kr_puts("[Bitwise]");
    kr_assert_true("has_flag(7,2)", kr_has_flag(7, 2));
    kr_assert_true("!has_flag(4,2)", !kr_has_flag(4, 2));
    kr_assert_eq_int("set_flag(4,2)", 6, kr_set_flag(4, 2));
    kr_assert_eq_int("toggle(7,2)", 5, kr_toggle_flag(7, 2));
    kr_puts("[String ==]");
    kr_assert_eq_str("classify hello", "greeting", kr_classify_word("hello"));
    kr_assert_eq_str("classify goodbye", "farewell", kr_classify_word("goodbye"));
    kr_assert_eq_str("classify empty", "empty", kr_classify_word(""));
    kr_assert_eq_str("classify other", "other", kr_classify_word("test"));
    kr_puts("[FizzBuzz]");
    kr_assert_eq_str("fizzbuzz(3)", "fizz", kr_fizzbuzz(3));
    kr_assert_eq_str("fizzbuzz(5)", "buzz", kr_fizzbuzz(5));
    kr_assert_eq_str("fizzbuzz(15)", "fizzbuzz", kr_fizzbuzz(15));
    kr_assert_eq_str("fizzbuzz(7)", "7", kr_fizzbuzz(7));
    kr_puts("[Nested]");
    kr_assert_eq_int("collatz(1)", 0, kr_collatz_steps(1));
    kr_assert_eq_int("collatz(6)", 8, kr_collatz_steps(6));
    kr_assert_eq_int("collatz(27)", 111, kr_collatz_steps(27));
    kr_puts("[For loop]");
    __auto_type sum = 0;
    for (int64_t i = 0; i < 10; i = i + 1) {
        sum = sum + i;
    }
    kr_assert_eq_int("for sum(0..10)", 45, sum);
    kr_puts("");
    kr_puts("=== All tests complete ===");
    return 0;
}


int main(int argc, char* argv[]) {
    return (int)kr_main();
}
