// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <ctype.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
int64_t kr_fclose(void* f) { return (int64_t)fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }
int64_t kr_vec_int_pop(void* vp) { KrVecInt* v = (KrVecInt*)vp; return v->data[--v->len]; }
void kr_vec_int_clear(void* vp) { ((KrVecInt*)vp)->len = 0; }
int64_t kr_vec_int_capacity(void* vp) { return ((KrVecInt*)vp)->cap; }
void kr_vec_int_reserve(void* vp, int64_t n) {
  KrVecInt* v = (KrVecInt*)vp; if(n>v->cap){v->cap=n;v->data=(int64_t*)realloc(v->data,n*sizeof(int64_t));}
}
void* kr_vec_int_with_capacity(int64_t n) {
  KrVecInt* v=(KrVecInt*)malloc(sizeof(KrVecInt));v->data=(int64_t*)malloc(n*sizeof(int64_t));v->len=0;v->cap=n;return v;
}
void kr_vec_int_insert(void* vp, int64_t i, int64_t val) {
  KrVecInt* v=(KrVecInt*)vp; kr_vec_int_push(vp,0); memmove(&v->data[i+1],&v->data[i],(v->len-i-1)*sizeof(int64_t)); v->data[i]=val;
}
int64_t kr_vec_int_remove(void* vp, int64_t i) {
  KrVecInt* v=(KrVecInt*)vp; int64_t val=v->data[i]; memmove(&v->data[i],&v->data[i+1],(v->len-i-1)*sizeof(int64_t)); v->len--; return val;
}
int64_t kr_vec_int_swap_remove(void* vp, int64_t i) { KrVecInt* v=(KrVecInt*)vp; int64_t val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
void kr_vec_int_shrink_to_fit(void* vp) { KrVecInt* v=(KrVecInt*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(int64_t*)realloc(v->data,v->cap*sizeof(int64_t));} }
kr_str kr_vec_string_pop(void* vp) { KrVecString* v = (KrVecString*)vp; return v->data[--v->len]; }
void kr_vec_string_clear(void* vp) { ((KrVecString*)vp)->len = 0; }
int64_t kr_vec_string_capacity(void* vp) { return ((KrVecString*)vp)->cap; }
void kr_vec_string_reserve(void* vp, int64_t n) {
  KrVecString* v = (KrVecString*)vp; if(n>v->cap){v->cap=n;v->data=(char**)realloc(v->data,n*sizeof(char*));}
}
void* kr_vec_string_with_capacity(int64_t n) {
  KrVecString* v=(KrVecString*)malloc(sizeof(KrVecString));v->data=(char**)malloc(n*sizeof(char*));v->len=0;v->cap=n;return v;
}
void kr_vec_string_shrink_to_fit(void* vp) { KrVecString* v=(KrVecString*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(char**)realloc(v->data,v->cap*sizeof(char*));} }
kr_str kr_vec_string_swap_remove(void* vp, int64_t i) { KrVecString* v=(KrVecString*)vp; kr_str val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
typedef struct { void** data; int64_t len; int64_t cap; } KrVecBytes;
void* kr_vec_bytes_new() { KrVecBytes* v=(KrVecBytes*)malloc(sizeof(KrVecBytes)); v->data=(void**)malloc(16*sizeof(void*)); v->len=0; v->cap=16; return v; }
void kr_vec_bytes_push(void* vp, void* val) { KrVecBytes* v=(KrVecBytes*)vp; if(v->len>=v->cap){v->cap*=2;v->data=(void**)realloc(v->data,v->cap*sizeof(void*));} v->data[v->len++]=val; }
void* kr_vec_bytes_get(void* vp, int64_t i) { return ((KrVecBytes*)vp)->data[i]; }
void kr_vec_bytes_set(void* vp, int64_t i, void* val) { ((KrVecBytes*)vp)->data[i]=val; }
int64_t kr_vec_bytes_len(void* vp) { return ((KrVecBytes*)vp)->len; }
void kr_vec_bytes_free(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; free(v->data); free(v); }
void* kr_vec_bytes_pop(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; return v->data[--v->len]; }
void kr_vec_bytes_clear(void* vp) { ((KrVecBytes*)vp)->len=0; }
int64_t kr_vec_bytes_capacity(void* vp) { return ((KrVecBytes*)vp)->cap; }
void kr_vec_bytes_reserve(void* vp, int64_t n) { KrVecBytes* v=(KrVecBytes*)vp; if(n>v->cap){v->cap=n;v->data=(void**)realloc(v->data,n*sizeof(void*));} }
void* kr_vec_bytes_with_capacity(int64_t n) { KrVecBytes* v=(KrVecBytes*)malloc(sizeof(KrVecBytes)); v->data=(void**)malloc(n*sizeof(void*)); v->len=0; v->cap=n; return v; }
void kr_vec_bytes_shrink_to_fit(void* vp) { KrVecBytes* v=(KrVecBytes*)vp; if(v->len<v->cap){v->cap=v->len?v->len:1;v->data=(void**)realloc(v->data,v->cap*sizeof(void*));} }
void* kr_vec_bytes_swap_remove(void* vp, int64_t i) { KrVecBytes* v=(KrVecBytes*)vp; void* val=v->data[i]; v->data[i]=v->data[--v->len]; return val; }
typedef struct { char** keys; int64_t* vals; int64_t cap; int64_t len; } KrMapSI;
static uint64_t _kr_hash_str(const char* s) { uint64_t h=5381; while(*s) h=h*33+(*s++); return h; }
void* kr_map_string_int_new() {
  KrMapSI* m=(KrMapSI*)malloc(sizeof(KrMapSI)); m->cap=64; m->len=0;
  m->keys=(char**)calloc(64,sizeof(char*)); m->vals=(int64_t*)calloc(64,sizeof(int64_t)); return m;
}
void kr_map_string_int_set(void* mp, kr_str key, int64_t val) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){m->vals[h]=val;return;} h=(h+1)%m->cap;}
  m->keys[h]=strdup(key); m->vals[h]=val; m->len++;
}
int64_t kr_map_string_int_get(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return m->vals[h]; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_int_has(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return 1; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_int_len(void* mp) { return ((KrMapSI*)mp)->len; }
void kr_map_string_int_delete(void* mp, kr_str key) {
  KrMapSI* m=(KrMapSI*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->keys[h]);m->keys[h]=NULL;m->len--;return;} h=(h+1)%m->cap;}
}
void kr_map_string_int_clear(void* mp) { KrMapSI* m=(KrMapSI*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i])free(m->keys[i]);m->keys[i]=NULL;} m->len=0; }
void kr_map_string_int_free(void* mp) { KrMapSI* m=(KrMapSI*)mp; for(int64_t i=0;i<m->cap;i++)if(m->keys[i])free(m->keys[i]); free(m->keys);free(m->vals);free(m); }
void* kr_map_string_int_keys(void* mp) { KrMapSI* m=(KrMapSI*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->keys[i]); return v; }
void* kr_map_string_int_values(void* mp) { KrMapSI* m=(KrMapSI*)mp; void* v=kr_vec_int_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_int_push(v,m->vals[i]); return v; }
typedef struct { char** keys; char** vals; int64_t cap; int64_t len; } KrMapSS;
void* kr_map_string_string_new() {
  KrMapSS* m=(KrMapSS*)malloc(sizeof(KrMapSS)); m->cap=64; m->len=0;
  m->keys=(char**)calloc(64,sizeof(char*)); m->vals=(char**)calloc(64,sizeof(char*)); return m;
}
void kr_map_string_string_set(void* mp, kr_str key, kr_str val) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->vals[h]);m->vals[h]=strdup(val);return;} h=(h+1)%m->cap;}
  m->keys[h]=strdup(key); m->vals[h]=strdup(val); m->len++;
}
kr_str kr_map_string_string_get(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return m->vals[h]; h=(h+1)%m->cap;} return "";
}
int64_t kr_map_string_string_has(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0) return 1; h=(h+1)%m->cap;} return 0;
}
int64_t kr_map_string_string_len(void* mp) { return ((KrMapSS*)mp)->len; }
void kr_map_string_string_delete(void* mp, kr_str key) {
  KrMapSS* m=(KrMapSS*)mp; uint64_t h=_kr_hash_str(key)%m->cap;
  while(m->keys[h]){if(strcmp(m->keys[h],key)==0){free(m->keys[h]);free(m->vals[h]);m->keys[h]=NULL;m->vals[h]=NULL;m->len--;return;} h=(h+1)%m->cap;}
}
void kr_map_string_string_clear(void* mp) { KrMapSS* m=(KrMapSS*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i]){free(m->keys[i]);free(m->vals[i]);m->keys[i]=NULL;m->vals[i]=NULL;}} m->len=0; }
void kr_map_string_string_free(void* mp) { KrMapSS* m=(KrMapSS*)mp; for(int64_t i=0;i<m->cap;i++){if(m->keys[i]){free(m->keys[i]);free(m->vals[i]);}} free(m->keys);free(m->vals);free(m); }
void* kr_map_string_string_keys(void* mp) { KrMapSS* m=(KrMapSS*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->keys[i]); return v; }
void* kr_map_string_string_values(void* mp) { KrMapSS* m=(KrMapSS*)mp; void* v=kr_vec_string_new(); for(int64_t i=0;i<m->cap;i++)if(m->keys[i])kr_vec_string_push(v,m->vals[i]); return v; }
kr_str kr_fmt_float(double v, ...) { char* r=(char*)malloc(64); snprintf(r,64,"%g",v); return r; }
kr_str kr_fmt_bool(int64_t v) { return v ? "true" : "false"; }
kr_str kr_fmt_hex(int64_t v) { char* r=(char*)malloc(32); snprintf(r,32,"0x%llx",(unsigned long long)v); return r; }
#define kr_printf(...) printf(__VA_ARGS__)
void kr_putchar(int64_t c) { putchar((int)c); }
int64_t kr_getchar() { return (int64_t)getchar(); }
void* kr_malloc(int64_t sz) { return malloc((size_t)sz); }
void kr_free(void* p) { free(p); }
void* kr_realloc(void* p, int64_t sz) { return realloc(p,(size_t)sz); }
int64_t kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
int64_t kr_str_ne(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
int64_t kr_str_len(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_str_contains(kr_str s, kr_str sub) { return strstr(s,sub)!=NULL; }
int64_t kr_str_starts_with(kr_str s, kr_str pfx) { return strncmp(s,pfx,strlen(pfx))==0; }
int64_t kr_str_index_of(kr_str s, kr_str sub) { char* p=strstr(s,sub); return p?(int64_t)(p-s):-1; }
kr_str kr_str_replace(kr_str s, kr_str old, kr_str rep) {
  size_t ol=strlen(old),rl=strlen(rep),sl=strlen(s); char* r=(char*)malloc(sl*2+1); char* w=r;
  while(*s){char* p=strstr(s,old);if(!p){strcpy(w,s);break;}memcpy(w,s,p-s);w+=p-s;memcpy(w,rep,rl);w+=rl;s=p+ol;}*w=0;return r;
}
kr_str kr_str_to_lower(kr_str s) { size_t n=strlen(s); char* r=(char*)malloc(n+1); for(size_t i=0;i<=n;i++)r[i]=tolower((unsigned char)s[i]); return r; }
kr_str kr_str_to_upper(kr_str s) { size_t n=strlen(s); char* r=(char*)malloc(n+1); for(size_t i=0;i<=n;i++)r[i]=toupper((unsigned char)s[i]); return r; }
kr_str kr_str_trim(kr_str s) { while(*s==' '||*s=='\t'||*s=='\n'||*s=='\r')s++; size_t n=strlen(s); while(n>0&&(s[n-1]==' '||s[n-1]=='\t'||s[n-1]=='\n'||s[n-1]=='\r'))n--; char* r=(char*)malloc(n+1); memcpy(r,s,n); r[n]=0; return r; }
kr_str kr_strdup(kr_str s) { return strdup(s); }
kr_str kr_from_cstr(void* p) { return p ? (kr_str)p : ""; }
void* kr_cstr(kr_str s) { return (void*)s; }
int64_t kr_str_char_count(kr_str s) { return (int64_t)strlen(s); }
kr_str kr_str_from_char_code(int64_t c) { char* r=(char*)malloc(2); r[0]=(char)c; r[1]=0; return r; }
kr_str kr_str_join(void* vp, kr_str sep) {
  KrVecString* v=(KrVecString*)vp; if(!v->len) return ""; size_t total=0,sl=strlen(sep);
  for(int64_t i=0;i<v->len;i++) total+=strlen(v->data[i]); total+=(v->len-1)*sl;
  char* r=(char*)malloc(total+1); char* w=r;
  for(int64_t i=0;i<v->len;i++){if(i>0){memcpy(w,sep,sl);w+=sl;}size_t n=strlen(v->data[i]);memcpy(w,v->data[i],n);w+=n;} *w=0; return r;
}
void* kr_str_split(kr_str s, kr_str sep) {
  void* v=kr_vec_string_new(); size_t sl=strlen(sep);
  while(*s){char* p=strstr(s,sep);if(!p){kr_vec_string_push(v,strdup(s));break;}
  char* chunk=(char*)malloc(p-s+1);memcpy(chunk,s,p-s);chunk[p-s]=0;kr_vec_string_push(v,chunk);s=p+sl;} return v;
}
int64_t kr_rand() { return (int64_t)rand(); }
void kr_srand(int64_t seed) { srand((unsigned)seed); }
double kr_sqrt(double x) { return sqrt(x); }
double kr_pow(double x, double y) { return pow(x,y); }
double kr_floor(double x) { return floor(x); }
double kr_ceil(double x) { return ceil(x); }
double kr_round(double x) { return round(x); }
double kr_sin(double x) { return sin(x); }
double kr_cos(double x) { return cos(x); }
double kr_tan(double x) { return tan(x); }
double kr_log(double x) { return log(x); }
double kr_log10(double x) { return log10(x); }
double kr_exp(double x) { return exp(x); }
double kr_fabs(double x) { return fabs(x); }
double kr_fmod(double x, double y) { return fmod(x,y); }
double kr_atan2(double y, double x) { return atan2(y,x); }
double kr_asin(double x) { return asin(x); }
double kr_acos(double x) { return acos(x); }
double kr_atan(double x) { return atan(x); }
double kr_sinh(double x) { return sinh(x); }
double kr_cosh(double x) { return cosh(x); }
double kr_tanh(double x) { return tanh(x); }
static int _kr_test_count=0, _kr_test_pass=0, _kr_test_fail=0;
static inline void _kr_default_test_section(kr_str name) { printf("--- %s ---\n", name); }
static inline void _kr_default_test_pass(kr_str msg) { _kr_test_count++; _kr_test_pass++; printf("  PASS: %s\n", msg); }
static inline void _kr_default_test_fail(kr_str msg) { _kr_test_count++; _kr_test_fail++; printf("  FAIL: %s\n", msg); }
static inline void _kr_default_test_skip(kr_str msg) { printf("  SKIP: %s\n", msg); }
static inline void _kr_default_assert(int64_t cond) { if(!cond){printf("ASSERTION FAILED\n");exit(1);} }
static inline void _kr_default_assert_eq(int64_t a, int64_t b) {
  _kr_test_count++; if(a==b){_kr_test_pass++;}else{_kr_test_fail++;printf("  ASSERT_EQ FAILED: %lld != %lld\n",(long long)a,(long long)b);}
}
static inline void _kr_default_assert_ne(int64_t a, int64_t b) {
  _kr_test_count++; if(a!=b){_kr_test_pass++;}else{_kr_test_fail++;printf("  ASSERT_NE FAILED: %lld == %lld\n",(long long)a,(long long)b);}
}
#define kr_test_section _kr_default_test_section
#define kr_test_pass _kr_default_test_pass
#define kr_test_fail _kr_default_test_fail
#define kr_test_skip _kr_default_test_skip
#define kr_assert _kr_default_assert
#define kr_assert_eq _kr_default_assert_eq
#define kr_assert_ne _kr_default_assert_ne
void* kr_mutex_create() { return malloc(64); }
void kr_mutex_destroy(void* m) { free(m); }
void kr_mutex_lock(void* m) { (void)m; }
void kr_mutex_unlock(void* m) { (void)m; }
void* kr_thread_spawn(void* fn) { (void)fn; return NULL; }
void kr_thread_join(void* h) { (void)h; }
void kr_sleep_ms(int64_t ms) { usleep((unsigned)(ms*1000)); }
int64_t kr_time() { return (int64_t)time(NULL); }
int64_t kr_isalpha(int64_t c) { return isalpha((int)c); }
int64_t kr_isdigit(int64_t c) { return isdigit((int)c); }
int64_t kr_isalnum(int64_t c) { return isalnum((int)c); }
int64_t kr_isupper(int64_t c) { return isupper((int)c); }
int64_t kr_islower(int64_t c) { return islower((int)c); }
int64_t kr_isspace(int64_t c) { return isspace((int)c); }
int64_t kr_tolower(int64_t c) { return (int64_t)tolower((int)c); }
int64_t kr_toupper(int64_t c) { return (int64_t)toupper((int)c); }
int64_t kr_atoi(kr_str s) { return (int64_t)atoi(s); }
double kr_atof(kr_str s) { return atof(s); }
void kr_abort() { abort(); }
kr_str kr_fgets(kr_str buf, int64_t n, void* f) { return fgets(buf,(int)n,(FILE*)f); }
int64_t kr_fwrite(void* ptr, int64_t size, int64_t count, void* f) { return (int64_t)fwrite(ptr,(size_t)size,(size_t)count,(FILE*)f); }
int64_t kr_fread(void* ptr, int64_t size, int64_t count, void* f) { return (int64_t)fread(ptr,(size_t)size,(size_t)count,(FILE*)f); }
int64_t kr_feof(void* f) { return (int64_t)feof((FILE*)f); }
int64_t kr_ferror(void* f) { return (int64_t)ferror((FILE*)f); }
int64_t kr_fflush(void* f) { return (int64_t)fflush((FILE*)f); }
int64_t kr_fgetc(void* f) { return (int64_t)fgetc((FILE*)f); }
int64_t kr_fputc(int64_t c, void* f) { return (int64_t)fputc((int)c,(FILE*)f); }
int64_t kr_fseek(void* f, int64_t off, int64_t w) { return (int64_t)fseek((FILE*)f,(long)off,(int)w); }
int64_t kr_ftell(void* f) { return (int64_t)ftell((FILE*)f); }
void kr_rewind(void* f) { rewind((FILE*)f); }
int64_t kr_memcmp(void* a, void* b, int64_t n) { return (int64_t)memcmp(a,b,(size_t)n); }
void* kr_memcpy(void* dst, void* src, int64_t n) { return memcpy(dst,src,(size_t)n); }
void* kr_memmove(void* dst, void* src, int64_t n) { return memmove(dst,src,(size_t)n); }
void* kr_memset(void* p, int64_t c, int64_t n) { return memset(p,(int)c,(size_t)n); }
void kr_setenv(kr_str name, kr_str val, ...) { setenv(name,val,1); }
void kr_unsetenv(kr_str name) { unsetenv(name); }
kr_str kr_strstr(kr_str haystack, kr_str needle) { char* p=strstr(haystack,needle); return p?p:""; }
kr_str kr_strchr(kr_str s, int64_t c) { char* p=strchr(s,(int)c); return p?p:""; }
kr_str kr_strncpy(kr_str dst, kr_str src, int64_t n) { return strncpy(dst,src,(size_t)n); }
kr_str kr_strcat(kr_str dst, kr_str src) { return strcat(dst,src); }
kr_str kr_strcpy(kr_str dst, kr_str src) { return strcpy(dst,src); }
int64_t kr_strncmp(kr_str a, kr_str b, int64_t n) { return (int64_t)strncmp(a,b,(size_t)n); }
kr_str kr_strtok(kr_str s, kr_str d) { return strtok(s,d); }
int64_t kr_str_is_valid_utf8(kr_str s) { while(*s){unsigned char c=*s;if(c<0x80)s++;else if((c&0xE0)==0xC0){if((s[1]&0xC0)!=0x80)return 0;s+=2;}else if((c&0xF0)==0xE0){if((s[1]&0xC0)!=0x80||(s[2]&0xC0)!=0x80)return 0;s+=3;}else if((c&0xF8)==0xF0){if((s[1]&0xC0)!=0x80||(s[2]&0xC0)!=0x80||(s[3]&0xC0)!=0x80)return 0;s+=4;}else return 0;} return 1; }
int64_t kr_str_char_at_utf8(kr_str s, int64_t idx) { return (int64_t)(unsigned char)s[idx]; }
int64_t kr_block_on(void* future) { (void)future; return 0; }
#define kr_sprintf(...) sprintf(__VA_ARGS__)
#define kr_sscanf(...) sscanf(__VA_ARGS__)
#define kr_snprintf(...) snprintf(__VA_ARGS__)
int64_t kr_rand_int(int64_t lo, int64_t hi) { return lo + (rand() % (hi - lo + 1)); }
double kr_rand_float() { return (double)rand() / (double)RAND_MAX; }
void kr_rand_seed(int64_t seed) { srand((unsigned)seed); }
int64_t kr_math_abs(int64_t x) { return x<0?-x:x; }
int64_t kr_math_min(int64_t a, int64_t b) { return a<b?a:b; }
int64_t kr_math_max(int64_t a, int64_t b) { return a>b?a:b; }
double kr_math_sqrt(double x) { return sqrt(x); }
double kr_math_floor(double x) { return floor(x); }
double kr_math_ceil(double x) { return ceil(x); }
double kr_math_round(double x) { return round(x); }
double kr_math_sin(double x) { return sin(x); }
double kr_math_cos(double x) { return cos(x); }
double kr_math_tan(double x) { return tan(x); }
double kr_math_pow(double x, double y) { return pow(x,y); }
void kr_log_debug(kr_str msg) { fprintf(stderr,"[DEBUG] %s\n",msg); }
void kr_log_info(kr_str msg) { fprintf(stderr,"[INFO] %s\n",msg); }
void kr_log_warn(kr_str msg) { fprintf(stderr,"[WARN] %s\n",msg); }
void kr_log_error(kr_str msg) { fprintf(stderr,"[ERROR] %s\n",msg); }
void kr_log_set_level(int64_t lvl) { (void)lvl; }
int64_t kr_bench_start() { return (int64_t)clock(); }
int64_t kr_bench_end(int64_t start, ...) { return (int64_t)clock() - start; }
int64_t kr_remove(kr_str path) { return (int64_t)remove(path); }
int64_t kr_rename(kr_str old, kr_str new_path) { return (int64_t)rename(old,new_path); }
void* kr_rand_bytes(int64_t n) { void* buf=malloc((size_t)n); for(int64_t i=0;i<n;i++)((char*)buf)[i]=(char)rand(); return buf; }
int64_t kr_bytes_eq(void* a, void* b, int64_t n) { return memcmp(a,b,(size_t)n)==0; }
void kr_println(kr_str s) { printf("%s\n",s); }
void* kr_mutex_new() { return malloc(64); }
void kr_mutex_free(void* m) { free(m); }
void* kr_channel_new() { return NULL; }
void* kr_channel_create(int64_t cap) { (void)cap; return NULL; }
void kr_channel_send(void* ch, int64_t val) { (void)ch; (void)val; }
int64_t kr_channel_recv(void* ch) { (void)ch; return 0; }
int64_t kr_channel_try_send(void* ch, int64_t val) { (void)ch; (void)val; return 0; }
int64_t kr_channel_try_recv(void* ch) { (void)ch; return 0; }
void kr_channel_close(void* ch) { (void)ch; }
void* kr_condvar_create() { return malloc(64); }
void kr_condvar_destroy(void* cv) { free(cv); }
void kr_condvar_signal(void* cv) { (void)cv; }
void kr_condvar_broadcast(void* cv) { (void)cv; }
void* kr_pool_new(int64_t n) { (void)n; return malloc(8); }
void kr_pool_shutdown(void* p) { free(p); }
void* kr_executor_new() { return malloc(8); }
void kr_executor_run(void* e) { (void)e; }
void kr_executor_shutdown(void* e) { free(e); }
void* kr_cancel_token_new() { return calloc(1,sizeof(int64_t)); }
void kr_cancel_token_cancel(void* t) { *(int64_t*)t=1; }
int64_t kr_cancel_token_is_cancelled(void* t) { return *(int64_t*)t; }

/* Forward declarations */
typedef struct Point Point;
typedef int64_t Direction;
Point kr_new_point(int64_t x, int64_t y);
int64_t kr_Point_dist_sq(Point self);
Point kr_Point_add(Point self, Point other);
kr_str kr_Point_to_string(Point self);
kr_str kr_dir_name(int64_t d);
kr_str kr_fizzbuzz(int64_t n);
int64_t kr_match_int(int64_t x);
int64_t kr_sum_range(int64_t start, int64_t end);
kr_str kr_repeat_str(kr_str s, int64_t n);
bool kr_has_flag(int64_t value, int64_t flag);
int64_t kr_set_flag(int64_t value, int64_t flag);
int64_t kr_toggle_flag(int64_t value, int64_t flag);
kr_str kr_classify_word(kr_str w);
int64_t kr_collatz_steps(int64_t n);
Point kr_trailing_comma_test();
void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual);
void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual);
void kr_assert_true(kr_str label, bool value);
int64_t kr_main();

struct Point {
int64_t x;
int64_t y;
};

typedef int64_t Direction;
#define Direction_North 0
#define Direction_South 1
#define Direction_East 2
#define Direction_West 3

Point kr_new_point(int64_t x, int64_t y) {
    return (Point){.x = x, .y = y};
}

int64_t kr_Point_dist_sq(Point self) {
    return self.x * self.x + self.y * self.y;
}

Point kr_Point_add(Point self, Point other) {
    return (Point){.x = self.x + other.x, .y = self.y + other.y};
}

kr_str kr_Point_to_string(Point self) {
    return kr_str_concat("(", kr_str_concat(kr_fmt_int(self.x), kr_str_concat(",", kr_str_concat(kr_fmt_int(self.y), ")"))));
}

kr_str kr_dir_name(int64_t d) {
    if (d == Direction_North) {
        return "north";
    }
    else if (d == Direction_South) {
        return "south";
    }
    else if (d == Direction_East) {
        return "east";
    }
    else if (d == Direction_West) {
        return "west";
    }
    else {
        return "unknown";
    }
    return "unreachable";
}

kr_str kr_fizzbuzz(int64_t n) {
    __auto_type m3 = n - (n / 3) * 3;
    __auto_type m5 = n - (n / 5) * 5;
    if (_KR_EQ(m3, 0) && _KR_EQ(m5, 0)) {
        return "fizzbuzz";
    }
    if (_KR_EQ(m3, 0)) {
        return "fizz";
    }
    if (_KR_EQ(m5, 0)) {
        return "buzz";
    }
    return kr_fmt_int(n);
}

int64_t kr_match_int(int64_t x) {
    if (x == 1) {
        return 10;
    }
    else if (x == 2) {
        return 20;
    }
    else if (x == 3) {
        return 30;
    }
    else {
        return 99;
    }
    return 0;
}

int64_t kr_sum_range(int64_t start, int64_t end) {
    __auto_type total = 0;
    for (int64_t i = start; i < end; i++) {
        total = total + i;
    }
    return total;
}

kr_str kr_repeat_str(kr_str s, int64_t n) {
    __auto_type result = "";
    __auto_type i = 0;
    while (i < n) {
        result = kr_str_concat(result, s);
        i = i + 1;
    }
    return result;
}

bool kr_has_flag(int64_t value, int64_t flag) {
    return _KR_NEQ((value & flag), 0);
}

int64_t kr_set_flag(int64_t value, int64_t flag) {
    return value | flag;
}

int64_t kr_toggle_flag(int64_t value, int64_t flag) {
    return value ^ flag;
}

kr_str kr_classify_word(kr_str w) {
    if (_KR_EQ(w, "hello")) {
        return "greeting";
    }
    if (_KR_EQ(w, "goodbye")) {
        return "farewell";
    }
    if (_KR_EQ(w, "")) {
        return "empty";
    }
    return "other";
}

int64_t kr_collatz_steps(int64_t n) {
    __auto_type steps = 0;
    __auto_type val = n;
    while (_KR_NEQ(val, 1)) {
        __auto_type m2 = val - (val / 2) * 2;
        if (_KR_EQ(m2, 0)) {
            val = val / 2;
        }
        else {
            val = val * 3 + 1;
        }
        steps = steps + 1;
    }
    return steps;
}

Point kr_trailing_comma_test() {
    return (Point){.x = 100, .y = 200};
}

void kr_assert_eq_int(kr_str label, int64_t expected, int64_t actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(kr_fmt_int(expected), kr_str_concat(" actual=", kr_fmt_int(actual)))))));
    }
}

void kr_assert_eq_str(kr_str label, kr_str expected, kr_str actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(expected, kr_str_concat(" actual=", actual))))));
    }
}

void kr_assert_true(kr_str label, bool value) {
    if (value) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", label));
    }
}

int64_t kr_main() {
    kr_puts("=== krakenc Translator Test Suite ===");
    kr_puts("");
    kr_puts("[Structs]");
    __auto_type p1 = kr_new_point(3, 4);
    kr_assert_eq_int("point.x", 3, p1.x);
    kr_assert_eq_int("point.y", 4, p1.y);
    kr_puts("[Impl]");
    kr_assert_eq_int("dist_sq(3,4)", 25, kr_Point_dist_sq(p1));
    __auto_type p2 = kr_new_point(1, 2);
    __auto_type p3 = kr_Point_add(p1, p2);
    kr_assert_eq_int("add.x", 4, p3.x);
    kr_assert_eq_int("add.y", 6, p3.y);
    kr_assert_eq_str("to_string", "(3,4)", kr_Point_to_string(p1));
    kr_puts("[Trailing Comma]");
    __auto_type tc = kr_trailing_comma_test();
    kr_assert_eq_int("trailing.x", 100, tc.x);
    kr_assert_eq_int("trailing.y", 200, tc.y);
    kr_puts("[Enums]");
    kr_assert_eq_str("dir north", "north", kr_dir_name(Direction_North));
    kr_assert_eq_str("dir south", "south", kr_dir_name(Direction_South));
    kr_assert_eq_str("dir east", "east", kr_dir_name(Direction_East));
    kr_assert_eq_str("dir west", "west", kr_dir_name(Direction_West));
    kr_puts("[Match]");
    kr_assert_eq_int("match(1)", 10, kr_match_int(1));
    kr_assert_eq_int("match(2)", 20, kr_match_int(2));
    kr_assert_eq_int("match(3)", 30, kr_match_int(3));
    kr_assert_eq_int("match(9)", 99, kr_match_int(9));
    kr_puts("[For-in]");
    kr_assert_eq_int("sum(0..5)", 10, kr_sum_range(0, 5));
    kr_assert_eq_int("sum(1..4)", 6, kr_sum_range(1, 4));
    kr_assert_eq_int("sum(0..1)", 0, kr_sum_range(0, 1));
    kr_puts("[While + String]");
    kr_assert_eq_str("repeat('ab',3)", "ababab", kr_repeat_str("ab", 3));
    kr_assert_eq_str("repeat('x',0)", "", kr_repeat_str("x", 0));
    kr_puts("[Bitwise]");
    kr_assert_true("has_flag(7,2)", kr_has_flag(7, 2));
    kr_assert_true("!has_flag(4,2)", !kr_has_flag(4, 2));
    kr_assert_eq_int("set_flag(4,2)", 6, kr_set_flag(4, 2));
    kr_assert_eq_int("toggle(7,2)", 5, kr_toggle_flag(7, 2));
    kr_puts("[String ==]");
    kr_assert_eq_str("classify hello", "greeting", kr_classify_word("hello"));
    kr_assert_eq_str("classify goodbye", "farewell", kr_classify_word("goodbye"));
    kr_assert_eq_str("classify empty", "empty", kr_classify_word(""));
    kr_assert_eq_str("classify other", "other", kr_classify_word("test"));
    kr_puts("[FizzBuzz]");
    kr_assert_eq_str("fizzbuzz(3)", "fizz", kr_fizzbuzz(3));
    kr_assert_eq_str("fizzbuzz(5)", "buzz", kr_fizzbuzz(5));
    kr_assert_eq_str("fizzbuzz(15)", "fizzbuzz", kr_fizzbuzz(15));
    kr_assert_eq_str("fizzbuzz(7)", "7", kr_fizzbuzz(7));
    kr_puts("[Nested]");
    kr_assert_eq_int("collatz(1)", 0, kr_collatz_steps(1));
    kr_assert_eq_int("collatz(6)", 8, kr_collatz_steps(6));
    kr_assert_eq_int("collatz(27)", 111, kr_collatz_steps(27));
    kr_puts("[For loop]");
    __auto_type sum = 0;
    for (int64_t i = 0; i < 10; i = i + 1) {
        sum = sum + i;
    }
    kr_assert_eq_int("for sum(0..10)", 45, sum);
    kr_puts("");
    kr_puts("=== All tests complete ===");
    return 0;
}


int main(int argc, char* argv[]) {
    kr_main();
    return 0;
}
