// Generated by krakenc â€” Kraken Self-Hosted Compiler
// Target: x86_64-apple-darwin

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

typedef int64_t kr_int;
typedef double kr_float;
typedef bool kr_bool;
typedef char* kr_str;
typedef ssize_t kr_size;

void kr_puts(kr_str s) { puts(s); }
int64_t kr_strlen(kr_str s) { return (int64_t)strlen(s); }
int64_t kr_abs(int64_t x) { return x < 0 ? -x : x; }
int kr_strcmp(kr_str a, kr_str b) { return strcmp(a, b); }
static inline bool _kr_str_eq(kr_str a, kr_str b) { return strcmp(a,b)==0; }
static inline bool _kr_str_neq(kr_str a, kr_str b) { return strcmp(a,b)!=0; }
static inline int _kr_cmp_eq(void* a, void* b) { return strcmp((char*)a,(char*)b)==0; }
static inline int _kr_cmp_neq(void* a, void* b) { return strcmp((char*)a,(char*)b)!=0; }
static inline int _kr_int_eq(int64_t a, int64_t b) { return a==b; }
static inline int _kr_int_neq(int64_t a, int64_t b) { return a!=b; }
#define _KR_EQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_eq((void*)(a),(void*)(b)), _kr_int_eq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#define _KR_NEQ(a, b) __builtin_choose_expr(__builtin_types_compatible_p(__typeof__(a), char*), _kr_cmp_neq((void*)(a),(void*)(b)), _kr_int_neq((int64_t)(intptr_t)(a),(int64_t)(intptr_t)(b)))
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"
kr_str kr_str_concat(kr_str a, kr_str b) {
  size_t la = strlen(a), lb = strlen(b);
  char* r = (char*)malloc(la + lb + 1);
  memcpy(r, a, la); memcpy(r + la, b, lb); r[la+lb] = 0; return r;
}
int64_t kr_str_char_at(kr_str s, int64_t i) { return (int64_t)(unsigned char)s[i]; }
kr_str kr_str_slice(kr_str s, int64_t start, int64_t end) {
  int64_t len = end - start; char* r = (char*)malloc(len + 1);
  memcpy(r, s + start, len); r[len] = 0; return r;
}
bool kr_str_ends_with(kr_str s, kr_str suffix) {
  size_t ls = strlen(s), lx = strlen(suffix);
  return lx <= ls && strcmp(s + ls - lx, suffix) == 0;
}
kr_str kr_fmt_int(int64_t v) {
  char* r = (char*)malloc(32); snprintf(r, 32, "%lld", (long long)v); return r;
}
kr_str kr_getenv(kr_str name) {
  char* v = (char*)getenv(name); return v ? v : (char*)"";
}
int64_t kr_system(kr_str cmd) { return (int64_t)system(cmd); }
void kr_exit(int64_t code) { exit((int)code); }
void* kr_fopen(kr_str path, kr_str mode) { return (void*)fopen(path, mode); }
void kr_fclose(void* f) { fclose((FILE*)f); }
void kr_fputs(kr_str s, void* f) { fputs(s, (FILE*)f); }
kr_str kr_file_read_string(kr_str path) {
  FILE* f = fopen(path, "rb"); if(!f) return "";
  fseek(f, 0, SEEK_END); long sz = ftell(f); fseek(f, 0, SEEK_SET);
  char* buf = (char*)malloc(sz + 1); fread(buf, 1, sz, f); buf[sz] = 0;
  fclose(f); return buf;
}
typedef struct { int64_t* data; int64_t len; int64_t cap; } KrVecInt;
void* kr_vec_int_new() {
  KrVecInt* v = (KrVecInt*)malloc(sizeof(KrVecInt));
  v->data = (int64_t*)malloc(16 * sizeof(int64_t)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_int_push(void* vp, int64_t val) {
  KrVecInt* v = (KrVecInt*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (int64_t*)realloc(v->data, v->cap * sizeof(int64_t)); }
  v->data[v->len++] = val;
}
int64_t kr_vec_int_get(void* vp, int64_t i) { return ((KrVecInt*)vp)->data[i]; }
void kr_vec_int_set(void* vp, int64_t i, int64_t val) { ((KrVecInt*)vp)->data[i] = val; }
int64_t kr_vec_int_len(void* vp) { return ((KrVecInt*)vp)->len; }
void kr_vec_int_free(void* vp) { KrVecInt* v = (KrVecInt*)vp; free(v->data); free(v); }
typedef struct { char** data; int64_t len; int64_t cap; } KrVecString;
void* kr_vec_string_new() {
  KrVecString* v = (KrVecString*)malloc(sizeof(KrVecString));
  v->data = (char**)malloc(16 * sizeof(char*)); v->len = 0; v->cap = 16; return v;
}
void kr_vec_string_push(void* vp, kr_str val) {
  KrVecString* v = (KrVecString*)vp;
  if(v->len >= v->cap) { v->cap *= 2; v->data = (char**)realloc(v->data, v->cap * sizeof(char*)); }
  v->data[v->len++] = val;
}
kr_str kr_vec_string_get(void* vp, int64_t i) { return ((KrVecString*)vp)->data[i]; }
void kr_vec_string_set(void* vp, int64_t i, kr_str val) { ((KrVecString*)vp)->data[i] = val; }
int64_t kr_vec_string_len(void* vp) { return ((KrVecString*)vp)->len; }
void kr_vec_string_free(void* vp) { KrVecString* v = (KrVecString*)vp; free(v->data); free(v); }

/* Forward declarations */
void kr_assert_eq(kr_str label, int64_t expected, int64_t actual);
void kr_assert_true(kr_str label, bool value);
int64_t kr_main();

void kr_assert_eq(kr_str label, int64_t expected, int64_t actual) {
    if (_KR_EQ(expected, actual)) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", kr_str_concat(label, kr_str_concat(" expected=", kr_str_concat(kr_fmt_int(expected), kr_str_concat(" actual=", kr_fmt_int(actual)))))));
    }
}

void kr_assert_true(kr_str label, bool value) {
    if (value) {
        kr_puts(kr_str_concat("  PASS: ", label));
    }
    else {
        kr_puts(kr_str_concat("  FAIL: ", label));
    }
}

int64_t kr_main() {
    kr_puts("=== krakenc Operator Tests ===");
    kr_puts("");
    kr_puts("[Shift]");
    kr_assert_eq("1<<3", 8, 1 << 3);
    kr_assert_eq("16>>2", 4, 16 >> 2);
    kr_assert_eq("255<<8", 65280, 255 << 8);
    kr_assert_eq("1024>>5", 32, 1024 >> 5);
    kr_puts("[Modulo]");
    kr_assert_eq("10%3", 1, 10 % 3);
    kr_assert_eq("7%2", 1, 7 % 2);
    kr_assert_eq("8%4", 0, 8 % 4);
    kr_assert_eq("15%7", 1, 15 % 7);
    kr_puts("[Compound Assign]");
    __auto_type x = 10;
    x += 5;
    kr_assert_eq("x+=5", 15, x);
    x -= 3;
    kr_assert_eq("x-=3", 12, x);
    x *= 2;
    kr_assert_eq("x*=2", 24, x);
    x /= 4;
    kr_assert_eq("x/=4", 6, x);
    x %= 4;
    kr_assert_eq("x%=4", 2, x);
    kr_puts("[Bitwise NOT]");
    int64_t mask = 255;
    kr_assert_eq("~0", -1, ~0);
    kr_assert_eq("~~5", 5, ~~5);
    kr_puts("[Unary Minus]");
    kr_assert_eq("-(-5)", 5, -(-5));
    kr_assert_eq("-(3+4)", -7, -(3 + 4));
    kr_puts("[Combined]");
    kr_assert_eq("(1<<4)|3", 19, (1 << 4) | 3);
    kr_assert_eq("(0xFF&0xF0)>>4", 15, (255 & 240) >> 4);
    kr_assert_eq("5+3*2", 11, 5 + 3 * 2);
    kr_assert_eq("(5+3)*2", 16, (5 + 3) * 2);
    kr_puts("[Shift + Compare]");
    kr_assert_true("1<<3 > 5", (1 << 3) > 5);
    kr_assert_true("16>>2 == 4", _KR_EQ((16 >> 2), 4));
    kr_puts("");
    kr_puts("=== All operator tests complete ===");
    return 0;
}


int main(int argc, char* argv[]) {
    return (int)kr_main();
}
